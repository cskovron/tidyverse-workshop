<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="dcterms.date" content="2018-07-18" />
  <title>Introduction to the tidyverse: tidying data with tidyr</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="part3_tidyr_files/reveal.js-3.3.0.1/css/reveal.css"/>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; } /* Keyword */
code > span.ch { color: #008080; } /* Char */
code > span.st { color: #008080; } /* String */
code > span.co { color: #008000; } /* Comment */
code > span.ot { color: #ff4000; } /* Other */
code > span.al { color: #ff0000; } /* Alert */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #008000; font-weight: bold; } /* Warning */
code > span.cn { } /* Constant */
code > span.sc { color: #008080; } /* SpecialChar */
code > span.vs { color: #008080; } /* VerbatimString */
code > span.ss { color: #008080; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #0000ff; } /* ControlFlow */
code > span.op { } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ff4000; } /* Preprocessor */
code > span.do { color: #008000; } /* Documentation */
code > span.an { color: #008000; } /* Annotation */
code > span.cv { color: #008000; } /* CommentVar */
code > span.at { } /* Attribute */
code > span.in { color: #008000; } /* Information */
</style>

<link rel="stylesheet" href="part3_tidyr_files/reveal.js-3.3.0.1/css/theme/simple.css" id="theme">


  <!-- some tweaks to reveal css -->
  <style type="text/css">
    .reveal h1 { font-size: 2.0em; }
    .reveal h2 { font-size: 1.5em;  }
    .reveal h3 { font-size: 1.25em;	}
    .reveal h4 { font-size: 1em;	}

    .reveal .slides>section,
    .reveal .slides>section>section {
      padding: 0px 0px;
    }



    .reveal table {
      border-width: 1px;
      border-spacing: 2px;
      border-style: dotted;
      border-color: gray;
      border-collapse: collapse;
      font-size: 0.7em;
    }

    .reveal table th {
      border-width: 1px;
      padding-left: 10px;
      padding-right: 25px;
      font-weight: bold;
      border-style: dotted;
      border-color: gray;
    }

    .reveal table td {
      border-width: 1px;
      padding-left: 10px;
      padding-right: 25px;
      border-style: dotted;
      border-color: gray;
    }


  </style>

    <style type="text/css">code{white-space: pre;}</style>


<!-- Printing and PDF exports -->
<script id="paper-css" type="application/dynamic-css">

/* Default Print Stylesheet Template
   by Rob Glazebrook of CSSnewbie.com
   Last Updated: June 4, 2008

   Feel free (nay, compelled) to edit, append, and
   manipulate this file as you see fit. */


@media print {

	/* SECTION 1: Set default width, margin, float, and
	   background. This prevents elements from extending
	   beyond the edge of the printed page, and prevents
	   unnecessary background images from printing */
	html {
		background: #fff;
		width: auto;
		height: auto;
		overflow: visible;
	}
	body {
		background: #fff;
		font-size: 20pt;
		width: auto;
		height: auto;
		border: 0;
		margin: 0 5%;
		padding: 0;
		overflow: visible;
		float: none !important;
	}

	/* SECTION 2: Remove any elements not needed in print.
	   This would include navigation, ads, sidebars, etc. */
	.nestedarrow,
	.controls,
	.fork-reveal,
	.share-reveal,
	.state-background,
	.reveal .progress,
	.reveal .backgrounds {
		display: none !important;
	}

	/* SECTION 3: Set body font face, size, and color.
	   Consider using a serif font for readability. */
	body, p, td, li, div {
		font-size: 20pt!important;
		font-family: Georgia, "Times New Roman", Times, serif !important;
		color: #000;
	}

	/* SECTION 4: Set heading font face, sizes, and color.
	   Differentiate your headings from your body text.
	   Perhaps use a large sans-serif for distinction. */
	h1,h2,h3,h4,h5,h6 {
		color: #000!important;
		height: auto;
		line-height: normal;
		font-family: Georgia, "Times New Roman", Times, serif !important;
		text-shadow: 0 0 0 #000 !important;
		text-align: left;
		letter-spacing: normal;
	}
	/* Need to reduce the size of the fonts for printing */
	h1 { font-size: 28pt !important;  }
	h2 { font-size: 24pt !important; }
	h3 { font-size: 22pt !important; }
	h4 { font-size: 22pt !important; font-variant: small-caps; }
	h5 { font-size: 21pt !important; }
	h6 { font-size: 20pt !important; font-style: italic; }

	/* SECTION 5: Make hyperlinks more usable.
	   Ensure links are underlined, and consider appending
	   the URL to the end of the link for usability. */
	a:link,
	a:visited {
		color: #000 !important;
		font-weight: bold;
		text-decoration: underline;
	}
	/*
	.reveal a:link:after,
	.reveal a:visited:after {
		content: " (" attr(href) ") ";
		color: #222 !important;
		font-size: 90%;
	}
	*/


	/* SECTION 6: more reveal.js specific additions by @skypanther */
	ul, ol, div, p {
		visibility: visible;
		position: static;
		width: auto;
		height: auto;
		display: block;
		overflow: visible;
		margin: 0;
		text-align: left !important;
	}
	.reveal pre,
	.reveal table {
		margin-left: 0;
		margin-right: 0;
	}
	.reveal pre code {
		padding: 20px;
		border: 1px solid #ddd;
	}
	.reveal blockquote {
		margin: 20px 0;
	}
	.reveal .slides {
		position: static !important;
		width: auto !important;
		height: auto !important;

		left: 0 !important;
		top: 0 !important;
		margin-left: 0 !important;
		margin-top: 0 !important;
		padding: 0 !important;
		zoom: 1 !important;

		overflow: visible !important;
		display: block !important;

		text-align: left !important;
		-webkit-perspective: none;
		   -moz-perspective: none;
		    -ms-perspective: none;
		        perspective: none;

		-webkit-perspective-origin: 50% 50%;
		   -moz-perspective-origin: 50% 50%;
		    -ms-perspective-origin: 50% 50%;
		        perspective-origin: 50% 50%;
	}
	.reveal .slides section {
		visibility: visible !important;
		position: static !important;
		width: auto !important;
		height: auto !important;
		display: block !important;
		overflow: visible !important;

		left: 0 !important;
		top: 0 !important;
		margin-left: 0 !important;
		margin-top: 0 !important;
		padding: 60px 20px !important;
		z-index: auto !important;

		opacity: 1 !important;

		page-break-after: always !important;

		-webkit-transform-style: flat !important;
		   -moz-transform-style: flat !important;
		    -ms-transform-style: flat !important;
		        transform-style: flat !important;

		-webkit-transform: none !important;
		   -moz-transform: none !important;
		    -ms-transform: none !important;
		        transform: none !important;

		-webkit-transition: none !important;
		   -moz-transition: none !important;
		    -ms-transition: none !important;
		        transition: none !important;
	}
	.reveal .slides section.stack {
		padding: 0 !important;
	}
	.reveal section:last-of-type {
		page-break-after: avoid !important;
	}
	.reveal section .fragment {
		opacity: 1 !important;
		visibility: visible !important;

		-webkit-transform: none !important;
		   -moz-transform: none !important;
		    -ms-transform: none !important;
		        transform: none !important;
	}
	.reveal section img {
		display: block;
		margin: 15px 0px;
		background: rgba(255,255,255,1);
		border: 1px solid #666;
		box-shadow: none;
	}

	.reveal section small {
		font-size: 0.8em;
	}

}  
</script>


<script id="pdf-css" type="application/dynamic-css">
    
/**
 * This stylesheet is used to print reveal.js
 * presentations to PDF.
 *
 * https://github.com/hakimel/reveal.js#pdf-export
 */

* {
	-webkit-print-color-adjust: exact;
}

body {
	margin: 0 auto !important;
	border: 0;
	padding: 0;
	float: none !important;
	overflow: visible;
}

html {
	width: 100%;
	height: 100%;
	overflow: visible;
}

/* Remove any elements not needed in print. */
.nestedarrow,
.reveal .controls,
.reveal .progress,
.reveal .playback,
.reveal.overview,
.fork-reveal,
.share-reveal,
.state-background {
	display: none !important;
}

h1, h2, h3, h4, h5, h6 {
	text-shadow: 0 0 0 #000 !important;
}

.reveal pre code {
	overflow: hidden !important;
	font-family: Courier, 'Courier New', monospace !important;
}

ul, ol, div, p {
	visibility: visible;
	position: static;
	width: auto;
	height: auto;
	display: block;
	overflow: visible;
	margin: auto;
}
.reveal {
	width: auto !important;
	height: auto !important;
	overflow: hidden !important;
}
.reveal .slides {
	position: static;
	width: 100%;
	height: auto;

	left: auto;
	top: auto;
	margin: 0 !important;
	padding: 0 !important;

	overflow: visible;
	display: block;

	-webkit-perspective: none;
	   -moz-perspective: none;
	    -ms-perspective: none;
	        perspective: none;

	-webkit-perspective-origin: 50% 50%; /* there isn't a none/auto value but 50-50 is the default */
	   -moz-perspective-origin: 50% 50%;
	    -ms-perspective-origin: 50% 50%;
	        perspective-origin: 50% 50%;
}

.reveal .slides section {
	page-break-after: always !important;

	visibility: visible !important;
	position: relative !important;
	display: block !important;
	position: relative !important;

	margin: 0 !important;
	padding: 0 !important;
	box-sizing: border-box !important;
	min-height: 1px;

	opacity: 1 !important;

	-webkit-transform-style: flat !important;
	   -moz-transform-style: flat !important;
	    -ms-transform-style: flat !important;
	        transform-style: flat !important;

	-webkit-transform: none !important;
	   -moz-transform: none !important;
	    -ms-transform: none !important;
	        transform: none !important;
}

.reveal section.stack {
	margin: 0 !important;
	padding: 0 !important;
	page-break-after: avoid !important;
	height: auto !important;
	min-height: auto !important;
}

.reveal img {
	box-shadow: none;
}

.reveal .roll {
	overflow: visible;
	line-height: 1em;
}

/* Slide backgrounds are placed inside of their slide when exporting to PDF */
.reveal section .slide-background {
	display: block !important;
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	z-index: -1;
}

/* All elements should be above the slide-background */
.reveal section>* {
	position: relative;
	z-index: 1;
}

/* Display slide speaker notes when 'showNotes' is enabled */
.reveal .speaker-notes-pdf {
	display: block;
	width: 100%;
	max-height: none;
	left: auto;
	top: auto;
	z-index: 100;
}

/* Display slide numbers when 'slideNumber' is enabled */
.reveal .slide-number-pdf {
	display: block;
	position: absolute;
	font-size: 14px;
}

</script>


<script>
var style = document.createElement( 'style' );
style.type = 'text/css';
var style_script_id = window.location.search.match( /print-pdf/gi ) ? 'pdf-css' : 'paper-css';
var style_script = document.getElementById(style_script_id).text;
style.innerHTML = style_script;
document.getElementsByTagName('head')[0].appendChild(style);
</script>

</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Introduction to the tidyverse: tidying data with <code>tidyr</code></h1>
    <h2 class="author"><div style="white-space: pre-line;">Christopher Skovron
Northwestern University</div></h2>
    <h3 class="date">July 18, 2018</h3>
</section>

<section id="materials" class="slide level2">
<h2>Materials</h2>
<p><a href="https://github.com/cskovron/tidyverse-workshop" class="uri">https://github.com/cskovron/tidyverse-workshop</a></p>
</section>
<section id="so-whats-a-tibble-anyway" class="slide level2">
<h2>So what’s a tibble, anyway?</h2>
<p>Tibbles <em>are</em> data frames, but they tweak some older behaviours to make life a little easier.</p>
<p>To learn more, check out <code>vignette(&quot;tibble&quot;)</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)</code></pre></div>
<pre><code>## Warning: package &#39;tibble&#39; was built under R version 3.4.3</code></pre>
<pre><code>## Warning: package &#39;tidyr&#39; was built under R version 3.4.3</code></pre>
<pre><code>## Warning: package &#39;stringr&#39; was built under R version 3.4.3</code></pre>
</section>
<section id="creating-tibbles" class="slide level2">
<h2>Creating tibbles</h2>
<p>Almost all of the functions in tidyverse produce tibbles, as tibbles are one of the unifying features of the tidyverse. Most other R packages use regular data frames, so you might want to coerce a data frame to a tibble. You can do that with <code>as_tibble()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as_tibble</span>(iris)</code></pre></div>
<pre><code>## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
##  1         5.10        3.50         1.40       0.200 setosa 
##  2         4.90        3.00         1.40       0.200 setosa 
##  3         4.70        3.20         1.30       0.200 setosa 
##  4         4.60        3.10         1.50       0.200 setosa 
##  5         5.00        3.60         1.40       0.200 setosa 
##  6         5.40        3.90         1.70       0.400 setosa 
##  7         4.60        3.40         1.40       0.300 setosa 
##  8         5.00        3.40         1.50       0.200 setosa 
##  9         4.40        2.90         1.40       0.200 setosa 
## 10         4.90        3.10         1.50       0.100 setosa 
## # ... with 140 more rows</code></pre>
</section>
<section id="creating-tibbles-1" class="slide level2">
<h2>Creating tibbles</h2>
<p>You can create a new tibble from individual vectors with <code>tibble()</code>. <code>tibble()</code> will automatically recycle inputs of length 1, and allows you to refer to variables that you just created, as shown below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, 
  <span class="dt">y =</span> <span class="dv">1</span>, 
  <span class="dt">z =</span> x <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>y
)</code></pre></div>
<pre><code>## # A tibble: 5 x 3
##       x     y     z
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1    1.    2.
## 2     2    1.    5.
## 3     3    1.   10.
## 4     4    1.   17.
## 5     5    1.   26.</code></pre>
</section>
<section id="differences-from-data.frame" class="slide level2">
<h2>Differences from <code>data.frame()</code></h2>
<p>If you’re already familiar with <code>data.frame()</code>, note that <code>tibble()</code> does much less: it never changes the type of the inputs (e.g. it never converts strings to factors!), it never changes the names of variables, and it never creates row names.</p>
</section>
<section id="tibble-column-names" class="slide level2">
<h2>tibble column names</h2>
<p>It’s possible for a tibble to have column names that are not valid R variable names, aka <strong>non-syntactic</strong> names. For example, they might not start with a letter, or they might contain unusual characters like a space. To refer to these variables, you need to surround them with backticks, <code>`</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tb &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="st">`</span><span class="dt">:)</span><span class="st">`</span> =<span class="st"> &quot;smile&quot;</span>, 
  <span class="st">`</span><span class="dt"> </span><span class="st">`</span> =<span class="st"> &quot;space&quot;</span>,
  <span class="st">`</span><span class="dt">2000</span><span class="st">`</span> =<span class="st"> &quot;number&quot;</span>
)
tb</code></pre></div>
<pre><code>## # A tibble: 1 x 3
##   `:)`  ` `   `2000`
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 
## 1 smile space number</code></pre>
<p>You’ll also need the backticks when working with these variables in other packages, like ggplot2, dplyr, and tidyr.</p>
</section>
<section id="tibbles-vs.data.frame" class="slide level2">
<h2>Tibbles vs. data.frame</h2>
<p>There are two main differences in the usage of a tibble vs. a classic <code>data.frame</code>: printing and subsetting.</p>
</section>
<section id="printing" class="slide level2">
<h2>Printing</h2>
<p>Tibbles have a refined print method that shows only the first 10 rows, and all the columns that fit on screen. This makes it much easier to work with large data. In addition to its name, each column reports its type, a nice feature borrowed from <code>str()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(
  <span class="dt">a =</span> lubridate<span class="op">::</span><span class="kw">now</span>() <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e3</span>) <span class="op">*</span><span class="st"> </span><span class="dv">86400</span>,
  <span class="dt">b =</span> lubridate<span class="op">::</span><span class="kw">today</span>() <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e3</span>) <span class="op">*</span><span class="st"> </span><span class="dv">30</span>,
  <span class="dt">c =</span> <span class="dv">1</span><span class="op">:</span><span class="fl">1e3</span>,
  <span class="dt">d =</span> <span class="kw">runif</span>(<span class="fl">1e3</span>),
  <span class="dt">e =</span> <span class="kw">sample</span>(letters, <span class="fl">1e3</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
)</code></pre></div>
<pre><code>## # A tibble: 1,000 x 5
##    a                   b              c      d e    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt;  &lt;dbl&gt; &lt;chr&gt;
##  1 2018-07-18 10:31:11 2018-08-06     1 0.227  o    
##  2 2018-07-19 03:16:56 2018-08-04     2 0.0276 t    
##  3 2018-07-19 04:00:00 2018-08-11     3 0.744  e    
##  4 2018-07-18 20:30:57 2018-08-06     4 0.821  r    
##  5 2018-07-18 04:28:34 2018-07-27     5 0.486  d    
##  6 2018-07-18 17:59:24 2018-07-28     6 0.204  j    
##  7 2018-07-18 17:36:44 2018-08-09     7 0.333  g    
##  8 2018-07-18 15:30:29 2018-08-01     8 0.148  w    
##  9 2018-07-18 10:20:21 2018-08-02     9 0.550  r    
## 10 2018-07-18 06:27:25 2018-08-01    10 0.365  z    
## # ... with 990 more rows</code></pre>
<p>Tibbles are designed so that you don’t accidentally overwhelm your console when you print large data frames. But sometimes you need more output than the default display. There are a few options that can help.</p>
<p>First, you can explicitly <code>print()</code> the data frame and control the number of rows (<code>n</code>) and the <code>width</code> of the display. <code>width = Inf</code> will display all columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nycflights13<span class="op">::</span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="dv">10</span>, <span class="dt">width =</span> <span class="ot">Inf</span>)</code></pre></div>
</section>
<section id="data-import-with-readr" class="slide level2">
<h2>Data import with readr</h2>
<p>If you’re used to base R, you’ve probably used functions from the <code>foreign</code> package to read in <code>.dta</code> Stata files, <code>.csv</code> files, and other data formats. <code>foreign</code> isn’t really that bad, but <code>readr</code> plays nicely with the tidyverse, is a little more flexible, and can be a lot faster.</p>
</section>
<section id="getting-started" class="slide level2">
<h2>Getting started</h2>
<p>Most of readr’s functions are concerned with turning flat files into data frames:</p>
<ul>
<li><p><code>read_csv()</code> reads comma delimited files, <code>read_csv2()</code> reads semicolon separated files (common in countries where <code>,</code> is used as the decimal place), <code>read_tsv()</code> reads tab delimited files, and <code>read_delim()</code> reads in files with any delimiter.</p></li>
<li><p><code>read_fwf()</code> reads fixed width files. You can specify fields either by their widths with <code>fwf_widths()</code> or their position with <code>fwf_positions()</code>. <code>read_table()</code> reads a common variation of fixed width files where columns are separated by white space.</p></li>
</ul>
</section>
<section id="arguments" class="slide level2">
<h2>Arguments</h2>
<p>The first argument to <code>read_csv()</code> is the most important: it’s the path to the file to read.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">heights &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/heights.csv&quot;</span>)</code></pre></div>
<p>When you run <code>read_csv()</code> it prints out a column specification that gives the name and type of each column.</p>
</section>
<section id="first-line-defaults-to-colnames-but-you-can-change-that" class="slide level2">
<h2>First line defaults to colnames, but you can change that</h2>
<ol type="1">
<li><p>Sometimes there are a few lines of metadata at the top of the file. You can use <code>skip = n</code> to skip the first <code>n</code> lines; or use <code>comment = &quot;#&quot;</code> to drop all lines that start with (e.g.) <code>#</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;The first line of metadata</span>
<span class="st">  The second line of metadata</span>
<span class="st">  x,y,z</span>
<span class="st">  1,2,3&quot;</span>, <span class="dt">skip =</span> <span class="dv">2</span>)</code></pre></div>
<pre><code>## # A tibble: 1 x 3
##       x     y     z
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     2     3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;# A comment I want to skip</span>
<span class="st">  x,y,z</span>
<span class="st">  1,2,3&quot;</span>, <span class="dt">comment =</span> <span class="st">&quot;#&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 1 x 3
##       x     y     z
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     2     3</code></pre></li>
</ol>
</section>
<section id="first-line-defaults-to-colnames-but-you-can-change-that-1" class="slide level2">
<h2>First line defaults to colnames, but you can change that</h2>
<p>The data might not have column names. You can use <code>col_names = FALSE</code> to tell <code>read_csv()</code> not to treat the first row as headings, and instead label them sequentially from <code>X1</code> to <code>Xn</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    <span class="kw">read_csv</span>(<span class="st">&quot;1,2,3</span><span class="ch">\n</span><span class="st">4,5,6&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##      X1    X2    X3
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     2     3
## 2     4     5     6</code></pre>
</section>
<section id="first-line-defaults-to-colnames-but-you-can-change-that-2" class="slide level2">
<h2>First line defaults to colnames, but you can change that</h2>
<p>Alternatively you can pass <code>col_names</code> a character vector which will be used as the column names:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    <span class="kw">read_csv</span>(<span class="st">&quot;1,2,3</span><span class="ch">\n</span><span class="st">4,5,6&quot;</span>, <span class="dt">col_names =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>))</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##       x     y     z
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     2     3
## 2     4     5     6</code></pre>
</section>
<section id="you-might-need-to-fix-nas." class="slide level2">
<h2>You might need to fix NAs.</h2>
<p>Another option that commonly needs tweaking is <code>na</code>: this specifies the value (or values) that are used to represent missing values in your file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a,b,c</span><span class="ch">\n</span><span class="st">1,2,.&quot;</span>, <span class="dt">na =</span> <span class="st">&quot;.&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 1 x 3
##       a     b c    
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;
## 1     1     2 &lt;NA&gt;</code></pre>
<p>This is all you need to know to read ~75% of CSV files that you’ll encounter in practice. You can also easily adapt what you’ve learned to read tab separated files with <code>read_tsv()</code> and fixed width files with <code>read_fwf()</code>. To read in more challenging files, you’ll need to learn more about how readr parses each column, turning them into R vectors.</p>
</section>
<section id="parsing" class="slide level2">
<h2>Parsing</h2>
<p>readr has lots of specialized tools for parsing different kinds of data at import. If you’re already working with nicely cleaned data, you won’t need to learn all of these. If you often work with data in non-standard formats, from Arabic-speaking countries, or from the distant past, check out <a href="http://r4ds.had.co.nz/data-import.html#parsing-a-vector">the relevant sections of R4DS</a>.</p>
</section>
<section id="parsing-decimals-across-cultures" class="slide level2">
<h2>Parsing decimals across cultures</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_double</span>(<span class="st">&quot;1.23&quot;</span>)</code></pre></div>
<pre><code>## [1] 1.23</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_double</span>(<span class="st">&quot;1,23&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">decimal_mark =</span> <span class="st">&quot;,&quot;</span>))</code></pre></div>
<pre><code>## [1] 1.23</code></pre>
</section>
<section id="clean-junk-out-of-your-numbers" class="slide level2">
<h2>Clean junk out of your numbers</h2>
<p><code>parse_number()</code> addresses the second problem: it ignores non-numeric characters before and after the number. This is particularly useful for currencies and percentages, but also works to extract numbers embedded in text.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_number</span>(<span class="st">&quot;$100&quot;</span>)</code></pre></div>
<pre><code>## [1] 100</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_number</span>(<span class="st">&quot;20%&quot;</span>)</code></pre></div>
<pre><code>## [1] 20</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_number</span>(<span class="st">&quot;It cost $123.45&quot;</span>)</code></pre></div>
<pre><code>## [1] 123.45</code></pre>
</section>
<section id="god-currency-data-is-awful" class="slide level2">
<h2>God, currency data is awful</h2>
<p>The final problem is addressed by the combination of <code>parse_number()</code> and the locale as <code>parse_number()</code> will ignore the “grouping mark”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Used in America</span>
<span class="kw">parse_number</span>(<span class="st">&quot;$123,456,789&quot;</span>)</code></pre></div>
<pre><code>## [1] 123456789</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Used in many parts of Europe</span>
<span class="kw">parse_number</span>(<span class="st">&quot;123.456.789&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">grouping_mark =</span> <span class="st">&quot;.&quot;</span>))</code></pre></div>
<pre><code>## [1] 123456789</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Used in Switzerland</span>
<span class="kw">parse_number</span>(<span class="st">&quot;123&#39;456&#39;789&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">grouping_mark =</span> <span class="st">&quot;&#39;&quot;</span>))</code></pre></div>
<pre><code>## [1] 123456789</code></pre>
</section>
<section id="study-up-on-your-own-on-character-encoding" class="slide level2">
<h2>Study up on your own on character encoding</h2>
</section>
<section id="factors" class="slide level2">
<h2>Factors</h2>
<p>R uses factors to represent categorical variables that have a known set of possible values. Give <code>parse_factor()</code> a vector of known <code>levels</code> to generate a warning whenever an unexpected value is present:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fruit &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;banana&quot;</span>)
<span class="kw">parse_factor</span>(<span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;banana&quot;</span>, <span class="st">&quot;bananana&quot;</span>), <span class="dt">levels =</span> fruit)</code></pre></div>
<pre><code>## Warning: 1 parsing failure.
## row # A tibble: 1 x 4 col     row   col expected           actual   expected   &lt;int&gt; &lt;int&gt; &lt;chr&gt;              &lt;chr&gt;    actual 1     3    NA value in level set bananana</code></pre>
<pre><code>## [1] apple  banana &lt;NA&gt;  
## attr(,&quot;problems&quot;)
## # A tibble: 1 x 4
##     row   col expected           actual  
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;              &lt;chr&gt;   
## 1     3    NA value in level set bananana
## Levels: apple banana</code></pre>
</section>
<section id="dates-date-times-and-times" class="slide level2">
<h2>Dates, date-times, and times</h2>
<p>You pick between three parsers depending on whether you want a date (the number of days since 1970-01-01), a date-time (the number of seconds since midnight 1970-01-01), or a time (the number of seconds since midnight). When called without any additional arguments:</p>
</section>
<section id="dates-date-times-and-times-1" class="slide level2">
<h2>Dates, date-times, and times</h2>
<ul>
<li><p><code>parse_datetime()</code> expects an ISO8601 date-time. ISO8601 is an international standard in which the components of a date are organised from biggest to smallest: year, month, day, hour, minute, second.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_datetime</span>(<span class="st">&quot;2010-10-01T2010&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;2010-10-01 20:10:00 UTC&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># If time is omitted, it will be set to midnight</span>
<span class="kw">parse_datetime</span>(<span class="st">&quot;20101010&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;2010-10-10 UTC&quot;</code></pre></li>
</ul>
</section>
<section id="dates-date-times-and-times-2" class="slide level2">
<h2>Dates, date-times, and times</h2>
<ul>
<li><p><code>parse_date()</code> expects a four digit year, a <code>-</code> or <code>/</code>, the month, a <code>-</code> or <code>/</code>, then the day:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_date</span>(<span class="st">&quot;2010-10-01&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;2010-10-01&quot;</code></pre></li>
</ul>
</section>
<section id="dates-date-times-and-times-3" class="slide level2">
<h2>Dates, date-times, and times</h2>
<ul>
<li><p><code>parse_time()</code> expects the hour, <code>:</code>, minutes, optionally <code>:</code> and seconds, and an optional am/pm specifier:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(hms)</code></pre></div>
<pre><code>## Warning: package &#39;hms&#39; was built under R version 3.4.3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_time</span>(<span class="st">&quot;01:10 am&quot;</span>)</code></pre></div>
<pre><code>## 01:10:00</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_time</span>(<span class="st">&quot;20:10:01&quot;</span>)</code></pre></div>
<pre><code>## 20:10:01</code></pre></li>
</ul>
</section>
<section id="other-types-of-data" class="slide level2">
<h2>Other types of data</h2>
<ul>
<li><p><strong>haven</strong> reads SPSS, Stata, and SAS files.</p></li>
<li><p><strong>readxl</strong> reads excel files (both <code>.xls</code> and <code>.xlsx</code>).</p></li>
<li><p><strong>DBI</strong>, along with a database specific backend (e.g. <strong>RMySQL</strong>, <strong>RSQLite</strong>, <strong>RPostgreSQL</strong> etc) allows you to run SQL queries against a database and return a data frame.</p></li>
</ul>
<p>For hierarchical data: use <strong>jsonlite</strong> (by Jeroen Ooms) for json, and <strong>xml2</strong> for XML. Jenny Bryan has some excellent worked examples at <a href="https://jennybc.github.io/purrr-tutorial/" class="uri">https://jennybc.github.io/purrr-tutorial/</a>.</p>
<p>For other file types, try the <a href="https://cran.r-project.org/doc/manuals/r-release/R-data.html">R data import/export manual</a> and the <a href="https://github.com/leeper/rio"><strong>rio</strong></a> package.</p>
</section>
<section id="tidy-data" class="slide level2">
<h2>Tidy data</h2>
</section>
<section id="hadley-has-jokes" class="slide level2">
<h2>Hadley has jokes</h2>
<blockquote>
<p>“Happy families are all alike; every unhappy family is unhappy in its own way.” –– Leo Tolstoy</p>
</blockquote>
<blockquote>
<p>“Tidy datasets are all alike, but every messy dataset is messy in its own way.” –– Hadley Wickham</p>
</blockquote>
</section>
<section id="tidy-data-1" class="slide level2">
<h2>Tidy data</h2>
<p>You can represent the same underlying data in multiple ways. The example below shows the same data organised in four different ways. Each dataset shows the same values of four variables <em>country</em>, <em>year</em>, <em>population</em>, and <em>cases</em>, but each dataset organises the values in a different way.</p>
</section>
<section id="table-1" class="slide level2">
<h2>Table 1</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table1</code></pre></div>
<pre><code>## # A tibble: 6 x 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
</section>
<section id="table-2" class="slide level2">
<h2>Table 2</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table2</code></pre></div>
<pre><code>## # A tibble: 12 x 4
##    country      year type            count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583</code></pre>
</section>
<section id="table-3" class="slide level2">
<h2>Table 3</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table3</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   country      year rate             
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583</code></pre>
</section>
<section id="table-4" class="slide level2">
<h2>Table 4</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Spread across two tibbles</span>
table4a  <span class="co"># cases</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   country     `1999` `2000`
## * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table4b  <span class="co"># population</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   country         `1999`     `2000`
## * &lt;chr&gt;            &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan   19987071   20595360
## 2 Brazil       172006362  174504898
## 3 China       1272915272 1280428583</code></pre>
</section>
<section id="tidy-data-principles" class="slide level2">
<h2>Tidy data principles</h2>
<p>There are three interrelated rules which make a dataset tidy:</p>
<ol type="1">
<li>Each variable must have its own column.</li>
<li>Each observation must have its own row.</li>
<li>Each value must have its own cell.</li>
</ol>
</section>
<section id="tidy-data-principles-1" class="slide level2">
<h2>Tidy data principles</h2>
<p><img src="../images/tidy-1.png" /></p>
</section>
<section id="tidy-data-principles-2" class="slide level2">
<h2>Tidy data principles</h2>
<p>These three rules are interrelated because it’s impossible to only satisfy two of the three. That interrelationship leads to an even simpler set of practical instructions:</p>
<ol type="1">
<li>Put each dataset in a tibble.</li>
<li>Put each variable in a column.</li>
</ol>
</section>
<section id="tidy-data-principles-3" class="slide level2">
<h2>Tidy data principles</h2>
<ul>
<li>Every data task will be different, but tidy data principles will help you keep organized</li>
<li>Much of your workflow will be getting data inputs into a tidy format</li>
<li>From the beginning, lay out what you need your dataset to look like to do the analyses you want, then work backward from there</li>
<li><a href="https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html">Hadley’s vignette on tidy data principles</a></li>
<li><a href="http://r4ds.had.co.nz/tidy-data.html">Chapter of R for Data Science on tidy data</a></li>
</ul>
</section>
<section id="tidy-data-has" class="slide level2">
<h2>Tidy data has</h2>
<ul>
<li>Each variable forms a column.</li>
<li>Each observation forms a row.</li>
<li>Each type of observational unit forms a table.</li>
</ul>
</section>
<section id="tidy-data-does-not-have" class="slide level2">
<h2>Tidy data does not have</h2>
<ul>
<li>Column headers are values, not variable names.</li>
<li>Multiple variables are stored in one column.</li>
<li>Variables are stored in both rows and columns.</li>
<li>Multiple types of observational units are stored in the same table.</li>
<li>A single observational unit is stored in multiple tables.</li>
</ul>
</section>
<section id="long-vs-wide-data" class="slide level2">
<h2>Long vs wide data</h2>
<p><img src="http://seananderson.ca/images/dcast-illustration.png" alt="via Sean Anderson" /></p>
</section>
<section id="relational-data" class="slide level2">
<h2>Relational data</h2>
<ul>
<li>Some data has structures more complex than simple tables</li>
<li>For example, Netflix has a database where each user has a table of movies they’ve watched and a separate table for each movie of the users who have watched it</li>
<li>This is “relational data”</li>
<li>It’s often, but not always, big</li>
<li>Requires special tools, usually SQL</li>
</ul>
</section>
<section id="checking-up-on-your-data-cleaning" class="slide level2">
<h2>Checking up on your data cleaning</h2>
<ul>
<li>glance at your data:
<ul>
<li><code>View()</code> (but be careful!)</li>
<li><code>summary()</code> (be careful on big datasets)</li>
<li><code>head()</code> and <code>tail()</code></li>
<li><code>tibble::glimpse()</code></li>
<li><code>is.na()</code> and <code>sum(is.na())</code></li>
</ul></li>
</ul>
</section>
<section id="spreading-and-gathering" class="slide level2">
<h2>Spreading and gathering</h2>
<p>The principles of tidy data seem so obvious that you might wonder if you’ll ever encounter a dataset that isn’t tidy. Unfortunately, however, most data that you will encounter will be untidy. There are two main reasons:</p>
<ol type="1">
<li><p>Most people aren’t familiar with the principles of tidy data, and it’s hard to derive them yourself unless you spend a <em>lot</em> of time working with data.</p></li>
<li><p>Data is often organised to facilitate some use other than analysis. For example, data is often organised to make entry as easy as possible.</p></li>
</ol>
</section>
<section id="common-problems" class="slide level2">
<h2>Common problems</h2>
<ol type="1">
<li><p>One variable might be spread across multiple columns.</p></li>
<li><p>One observation might be scattered across multiple rows.</p></li>
</ol>
<p>Typically a dataset will only suffer from one of these problems; it’ll only suffer from both if you’re really unlucky! To fix these problems, you’ll need the two most important functions in tidyr: <code>gather()</code> and <code>spread()</code>.</p>
</section>
<section id="gathering" class="slide level2">
<h2>Gathering</h2>
<p>A common problem is a dataset where some of the column names are not names of variables, but <em>values</em> of a variable. Take <code>table4a</code>: the column names <code>1999</code> and <code>2000</code> represent values of the <code>year</code> variable, and each row represents two observations, not one.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table4a</code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   country     `1999` `2000`
## * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766</code></pre>
</section>
<section id="gathering-1" class="slide level2">
<h2>Gathering</h2>
<p>To tidy a dataset like this, we need to <strong>gather</strong> those columns into a new pair of variables. To describe that operation we need three parameters:</p>
<ul>
<li><p>The set of columns that represent values, not variables. In this example, those are the columns <code>1999</code> and <code>2000</code>.</p></li>
<li><p>The name of the variable whose values form the column names. I call that the <code>key</code>, and here it is <code>year</code>.</p></li>
<li><p>The name of the variable whose values are spread over the cells. I call that <code>value</code>, and here it’s the number of <code>cases</code>.</p></li>
</ul>
</section>
<section id="gathering-2" class="slide level2">
<h2>Gathering</h2>
<p>Together those parameters generate the call to <code>gather()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table4a <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cases&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   country     year   cases
##   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;
## 1 Afghanistan 1999     745
## 2 Brazil      1999   37737
## 3 China       1999  212258
## 4 Afghanistan 2000    2666
## 5 Brazil      2000   80488
## 6 China       2000  213766</code></pre>
<p>The columns to gather are specified with <code>dplyr::select()</code> style notation. Here there are only two columns, so we list them individually. Note that “1999” and “2000” are non-syntactic names (because they don’t start with a letter) so we have to surround them in backticks.</p>
</section>
<section id="gathering-3" class="slide level2">
<h2>Gathering</h2>
<p><img src="../images/tidy-9.png" /></p>
</section>
<section id="gathering-4" class="slide level2">
<h2>Gathering</h2>
<p>In the final result, the gathered columns are dropped, and we get new <code>key</code> and <code>value</code> columns.</p>
<p>To combine the tidied versions of <code>table4a</code> and <code>table4b</code> into a single tibble, we need to use <code>dplyr::left_join()</code>, which you’ll learn about in <a href="#/relational-data">relational data</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tidy4a &lt;-<span class="st"> </span>table4a <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cases&quot;</span>)
tidy4b &lt;-<span class="st"> </span>table4b <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;population&quot;</span>)
<span class="kw">left_join</span>(tidy4a, tidy4b)</code></pre></div>
<pre><code>## Joining, by = c(&quot;country&quot;, &quot;year&quot;)</code></pre>
<pre><code>## # A tibble: 6 x 4
##   country     year   cases population
##   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan 1999     745   19987071
## 2 Brazil      1999   37737  172006362
## 3 China       1999  212258 1272915272
## 4 Afghanistan 2000    2666   20595360
## 5 Brazil      2000   80488  174504898
## 6 China       2000  213766 1280428583</code></pre>
</section>
<section id="spreading" class="slide level2">
<h2>Spreading</h2>
<p>Spreading is the opposite of gathering. You use it when an observation is scattered across multiple rows. For example, take <code>table2</code>: an observation is a country in a year, but each observation is spread across two rows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table2</code></pre></div>
<pre><code>## # A tibble: 12 x 4
##    country      year type            count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583</code></pre>
<p>To tidy this up, we first analyse the representation in similar way to <code>gather()</code>. This time, however, we only need two parameters:</p>
<ul>
<li><p>The column that contains variable names, the <code>key</code> column. Here, it’s <code>type</code>.</p></li>
<li><p>The column that contains values forms multiple variables, the <code>value</code> column. Here it’s <code>count</code>.</p></li>
</ul>
</section>
<section id="spreading-1" class="slide level2">
<h2>Spreading</h2>
<p>Once we’ve figured that out, we can use <code>spread()</code>, as shown programmatically below, and visually in Figure @ref(fig:tidy-spread).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">spread</span>(table2, <span class="dt">key =</span> type, <span class="dt">value =</span> count)</code></pre></div>
<pre><code>## # A tibble: 6 x 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<div class="figure">
<img src="images/tidy-8.png" alt="Spreading `table2` makes it tidy" width="100%" />
<p class="caption">
Spreading <code>table2</code> makes it tidy
</p>
</div>
<p>As you might have guessed from the common <code>key</code> and <code>value</code> arguments, <code>spread()</code> and <code>gather()</code> are complements. <code>gather()</code> makes wide tables narrower and longer; <code>spread()</code> makes long tables shorter and wider.</p>
</section>
<section id="separating-and-uniting" class="slide level2">
<h2>Separating and uniting</h2>
<p>So far you’ve learned how to tidy <code>table2</code> and <code>table4</code>, but not <code>table3</code>. <code>table3</code> has a different problem: we have one column (<code>rate</code>) that contains two variables (<code>cases</code> and <code>population</code>). To fix this problem, we’ll need the <code>separate()</code> function. You’ll also learn about the complement of <code>separate()</code>: <code>unite()</code>, which you use if a single variable is spread across multiple columns.</p>
</section>
<section id="separate" class="slide level2">
<h2>Separate</h2>
<p><code>separate()</code> pulls apart one column into multiple columns, by splitting wherever a separator character appears. Take <code>table3</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table3</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   country      year rate             
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583</code></pre>
</section>
<section id="separate-1" class="slide level2">
<h2>Separate</h2>
<p>The <code>rate</code> column contains both <code>cases</code> and <code>population</code> variables, and we need to split it into two variables. <code>separate()</code> takes the name of the column to separate, and the names of the columns to separate into, as shown in Figure @ref(fig:tidy-separate) and the code below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(rate, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;cases&quot;</span>, <span class="st">&quot;population&quot;</span>))</code></pre></div>
<pre><code>## # A tibble: 6 x 4
##   country      year cases  population
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
## 1 Afghanistan  1999 745    19987071  
## 2 Afghanistan  2000 2666   20595360  
## 3 Brazil       1999 37737  172006362 
## 4 Brazil       2000 80488  174504898 
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
</section>
<section id="separate-2" class="slide level2">
<h2>Separate</h2>
<p>By default, <code>separate()</code> will split values wherever it sees a non-alphanumeric character (i.e. a character that isn’t a number or letter). For example, in the code above, <code>separate()</code> split the values of <code>rate</code> at the forward slash characters. If you wish to use a specific character to separate a column, you can pass the character to the <code>sep</code> argument of <code>separate()</code>. For example, we could rewrite the code above as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(rate, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;cases&quot;</span>, <span class="st">&quot;population&quot;</span>), <span class="dt">sep =</span> <span class="st">&quot;/&quot;</span>)</code></pre></div>
</section>
<section id="unite" class="slide level2">
<h2>Unite</h2>
<p><code>unite()</code> is the inverse of <code>separate()</code>: it combines multiple columns into a single column. You’ll need it much less frequently than <code>separate()</code>, but it’s still a useful tool to have in your back pocket.</p>
</section>
<section id="unite-1" class="slide level2">
<h2>Unite</h2>
<p>We can use <code>unite()</code> to rejoin the <em>century</em> and <em>year</em> columns that we created in the last example. That data is saved as <code>tidyr::table5</code>. <code>unite()</code> takes a data frame, the name of the new variable to create, and a set of columns to combine, again specified in <code>dplyr::select()</code> style:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table5 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unite</span>(new, century, year)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   country     new   rate             
##   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;            
## 1 Afghanistan 19_99 745/19987071     
## 2 Afghanistan 20_00 2666/20595360    
## 3 Brazil      19_99 37737/172006362  
## 4 Brazil      20_00 80488/174504898  
## 5 China       19_99 212258/1272915272
## 6 China       20_00 213766/1280428583</code></pre>
</section>
    </div>
  </div>

  <script src="part3_tidyr_files/reveal.js-3.3.0.1/lib/js/head.min.js"></script>
  <script src="part3_tidyr_files/reveal.js-3.3.0.1/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Vertical centering of slides
        center: false,
        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom
        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom



        // Optional reveal.js plugins
        dependencies: [
        ]
      });
    </script>
  <!-- dynamically load mathjax for compatibility with self-contained -->
  <script>
    (function () {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
      document.getElementsByTagName("head")[0].appendChild(script);
    })();
  </script>

<script>
  (function() {
    if (window.jQuery) {
      Reveal.addEventListener( 'slidechanged', function(event) {  
        window.jQuery(event.previousSlide).trigger('hidden');
        window.jQuery(event.currentSlide).trigger('shown');
      });
    }
  })();
</script>


  </body>
</html>
