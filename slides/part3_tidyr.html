<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="dcterms.date" content="2018-07-16" />
  <title>Introduction to the tidyverse: tidying data with tidyr</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="part3_tidyr_files/reveal.js-3.3.0.1/css/reveal.css"/>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; } /* Keyword */
code > span.ch { color: #008080; } /* Char */
code > span.st { color: #008080; } /* String */
code > span.co { color: #008000; } /* Comment */
code > span.ot { color: #ff4000; } /* Other */
code > span.al { color: #ff0000; } /* Alert */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #008000; font-weight: bold; } /* Warning */
code > span.cn { } /* Constant */
code > span.sc { color: #008080; } /* SpecialChar */
code > span.vs { color: #008080; } /* VerbatimString */
code > span.ss { color: #008080; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #0000ff; } /* ControlFlow */
code > span.op { } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ff4000; } /* Preprocessor */
code > span.do { color: #008000; } /* Documentation */
code > span.an { color: #008000; } /* Annotation */
code > span.cv { color: #008000; } /* CommentVar */
code > span.at { } /* Attribute */
code > span.in { color: #008000; } /* Information */
</style>

<link rel="stylesheet" href="part3_tidyr_files/reveal.js-3.3.0.1/css/theme/simple.css" id="theme">


  <!-- some tweaks to reveal css -->
  <style type="text/css">
    .reveal h1 { font-size: 2.0em; }
    .reveal h2 { font-size: 1.5em;  }
    .reveal h3 { font-size: 1.25em;	}
    .reveal h4 { font-size: 1em;	}

    .reveal .slides>section,
    .reveal .slides>section>section {
      padding: 0px 0px;
    }



    .reveal table {
      border-width: 1px;
      border-spacing: 2px;
      border-style: dotted;
      border-color: gray;
      border-collapse: collapse;
      font-size: 0.7em;
    }

    .reveal table th {
      border-width: 1px;
      padding-left: 10px;
      padding-right: 25px;
      font-weight: bold;
      border-style: dotted;
      border-color: gray;
    }

    .reveal table td {
      border-width: 1px;
      padding-left: 10px;
      padding-right: 25px;
      border-style: dotted;
      border-color: gray;
    }


  </style>

    <style type="text/css">code{white-space: pre;}</style>


<!-- Printing and PDF exports -->
<script id="paper-css" type="application/dynamic-css">

/* Default Print Stylesheet Template
   by Rob Glazebrook of CSSnewbie.com
   Last Updated: June 4, 2008

   Feel free (nay, compelled) to edit, append, and
   manipulate this file as you see fit. */


@media print {

	/* SECTION 1: Set default width, margin, float, and
	   background. This prevents elements from extending
	   beyond the edge of the printed page, and prevents
	   unnecessary background images from printing */
	html {
		background: #fff;
		width: auto;
		height: auto;
		overflow: visible;
	}
	body {
		background: #fff;
		font-size: 20pt;
		width: auto;
		height: auto;
		border: 0;
		margin: 0 5%;
		padding: 0;
		overflow: visible;
		float: none !important;
	}

	/* SECTION 2: Remove any elements not needed in print.
	   This would include navigation, ads, sidebars, etc. */
	.nestedarrow,
	.controls,
	.fork-reveal,
	.share-reveal,
	.state-background,
	.reveal .progress,
	.reveal .backgrounds {
		display: none !important;
	}

	/* SECTION 3: Set body font face, size, and color.
	   Consider using a serif font for readability. */
	body, p, td, li, div {
		font-size: 20pt!important;
		font-family: Georgia, "Times New Roman", Times, serif !important;
		color: #000;
	}

	/* SECTION 4: Set heading font face, sizes, and color.
	   Differentiate your headings from your body text.
	   Perhaps use a large sans-serif for distinction. */
	h1,h2,h3,h4,h5,h6 {
		color: #000!important;
		height: auto;
		line-height: normal;
		font-family: Georgia, "Times New Roman", Times, serif !important;
		text-shadow: 0 0 0 #000 !important;
		text-align: left;
		letter-spacing: normal;
	}
	/* Need to reduce the size of the fonts for printing */
	h1 { font-size: 28pt !important;  }
	h2 { font-size: 24pt !important; }
	h3 { font-size: 22pt !important; }
	h4 { font-size: 22pt !important; font-variant: small-caps; }
	h5 { font-size: 21pt !important; }
	h6 { font-size: 20pt !important; font-style: italic; }

	/* SECTION 5: Make hyperlinks more usable.
	   Ensure links are underlined, and consider appending
	   the URL to the end of the link for usability. */
	a:link,
	a:visited {
		color: #000 !important;
		font-weight: bold;
		text-decoration: underline;
	}
	/*
	.reveal a:link:after,
	.reveal a:visited:after {
		content: " (" attr(href) ") ";
		color: #222 !important;
		font-size: 90%;
	}
	*/


	/* SECTION 6: more reveal.js specific additions by @skypanther */
	ul, ol, div, p {
		visibility: visible;
		position: static;
		width: auto;
		height: auto;
		display: block;
		overflow: visible;
		margin: 0;
		text-align: left !important;
	}
	.reveal pre,
	.reveal table {
		margin-left: 0;
		margin-right: 0;
	}
	.reveal pre code {
		padding: 20px;
		border: 1px solid #ddd;
	}
	.reveal blockquote {
		margin: 20px 0;
	}
	.reveal .slides {
		position: static !important;
		width: auto !important;
		height: auto !important;

		left: 0 !important;
		top: 0 !important;
		margin-left: 0 !important;
		margin-top: 0 !important;
		padding: 0 !important;
		zoom: 1 !important;

		overflow: visible !important;
		display: block !important;

		text-align: left !important;
		-webkit-perspective: none;
		   -moz-perspective: none;
		    -ms-perspective: none;
		        perspective: none;

		-webkit-perspective-origin: 50% 50%;
		   -moz-perspective-origin: 50% 50%;
		    -ms-perspective-origin: 50% 50%;
		        perspective-origin: 50% 50%;
	}
	.reveal .slides section {
		visibility: visible !important;
		position: static !important;
		width: auto !important;
		height: auto !important;
		display: block !important;
		overflow: visible !important;

		left: 0 !important;
		top: 0 !important;
		margin-left: 0 !important;
		margin-top: 0 !important;
		padding: 60px 20px !important;
		z-index: auto !important;

		opacity: 1 !important;

		page-break-after: always !important;

		-webkit-transform-style: flat !important;
		   -moz-transform-style: flat !important;
		    -ms-transform-style: flat !important;
		        transform-style: flat !important;

		-webkit-transform: none !important;
		   -moz-transform: none !important;
		    -ms-transform: none !important;
		        transform: none !important;

		-webkit-transition: none !important;
		   -moz-transition: none !important;
		    -ms-transition: none !important;
		        transition: none !important;
	}
	.reveal .slides section.stack {
		padding: 0 !important;
	}
	.reveal section:last-of-type {
		page-break-after: avoid !important;
	}
	.reveal section .fragment {
		opacity: 1 !important;
		visibility: visible !important;

		-webkit-transform: none !important;
		   -moz-transform: none !important;
		    -ms-transform: none !important;
		        transform: none !important;
	}
	.reveal section img {
		display: block;
		margin: 15px 0px;
		background: rgba(255,255,255,1);
		border: 1px solid #666;
		box-shadow: none;
	}

	.reveal section small {
		font-size: 0.8em;
	}

}  
</script>


<script id="pdf-css" type="application/dynamic-css">
    
/**
 * This stylesheet is used to print reveal.js
 * presentations to PDF.
 *
 * https://github.com/hakimel/reveal.js#pdf-export
 */

* {
	-webkit-print-color-adjust: exact;
}

body {
	margin: 0 auto !important;
	border: 0;
	padding: 0;
	float: none !important;
	overflow: visible;
}

html {
	width: 100%;
	height: 100%;
	overflow: visible;
}

/* Remove any elements not needed in print. */
.nestedarrow,
.reveal .controls,
.reveal .progress,
.reveal .playback,
.reveal.overview,
.fork-reveal,
.share-reveal,
.state-background {
	display: none !important;
}

h1, h2, h3, h4, h5, h6 {
	text-shadow: 0 0 0 #000 !important;
}

.reveal pre code {
	overflow: hidden !important;
	font-family: Courier, 'Courier New', monospace !important;
}

ul, ol, div, p {
	visibility: visible;
	position: static;
	width: auto;
	height: auto;
	display: block;
	overflow: visible;
	margin: auto;
}
.reveal {
	width: auto !important;
	height: auto !important;
	overflow: hidden !important;
}
.reveal .slides {
	position: static;
	width: 100%;
	height: auto;

	left: auto;
	top: auto;
	margin: 0 !important;
	padding: 0 !important;

	overflow: visible;
	display: block;

	-webkit-perspective: none;
	   -moz-perspective: none;
	    -ms-perspective: none;
	        perspective: none;

	-webkit-perspective-origin: 50% 50%; /* there isn't a none/auto value but 50-50 is the default */
	   -moz-perspective-origin: 50% 50%;
	    -ms-perspective-origin: 50% 50%;
	        perspective-origin: 50% 50%;
}

.reveal .slides section {
	page-break-after: always !important;

	visibility: visible !important;
	position: relative !important;
	display: block !important;
	position: relative !important;

	margin: 0 !important;
	padding: 0 !important;
	box-sizing: border-box !important;
	min-height: 1px;

	opacity: 1 !important;

	-webkit-transform-style: flat !important;
	   -moz-transform-style: flat !important;
	    -ms-transform-style: flat !important;
	        transform-style: flat !important;

	-webkit-transform: none !important;
	   -moz-transform: none !important;
	    -ms-transform: none !important;
	        transform: none !important;
}

.reveal section.stack {
	margin: 0 !important;
	padding: 0 !important;
	page-break-after: avoid !important;
	height: auto !important;
	min-height: auto !important;
}

.reveal img {
	box-shadow: none;
}

.reveal .roll {
	overflow: visible;
	line-height: 1em;
}

/* Slide backgrounds are placed inside of their slide when exporting to PDF */
.reveal section .slide-background {
	display: block !important;
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	z-index: -1;
}

/* All elements should be above the slide-background */
.reveal section>* {
	position: relative;
	z-index: 1;
}

/* Display slide speaker notes when 'showNotes' is enabled */
.reveal .speaker-notes-pdf {
	display: block;
	width: 100%;
	max-height: none;
	left: auto;
	top: auto;
	z-index: 100;
}

/* Display slide numbers when 'slideNumber' is enabled */
.reveal .slide-number-pdf {
	display: block;
	position: absolute;
	font-size: 14px;
}

</script>


<script>
var style = document.createElement( 'style' );
style.type = 'text/css';
var style_script_id = window.location.search.match( /print-pdf/gi ) ? 'pdf-css' : 'paper-css';
var style_script = document.getElementById(style_script_id).text;
style.innerHTML = style_script;
document.getElementsByTagName('head')[0].appendChild(style);
</script>

</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Introduction to the tidyverse: tidying data with <code>tidyr</code></h1>
    <h2 class="author"><div style="white-space: pre-line;">Christopher Skovron
Northwestern University</div></h2>
    <h3 class="date">July 16, 2018</h3>
</section>

<section id="so-whats-a-tibble-anyway" class="slide level2">
<h2>So what’s a tibble, anyway?</h2>
<p>Tibbles <em>are</em> data frames, but they tweak some older behaviours to make life a little easier.</p>
<p>To learn more, check out <code>vignette(&quot;tibble&quot;)</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)</code></pre></div>
<pre><code>## Warning: package &#39;tibble&#39; was built under R version 3.4.3</code></pre>
<pre><code>## Warning: package &#39;tidyr&#39; was built under R version 3.4.3</code></pre>
<pre><code>## Warning: package &#39;stringr&#39; was built under R version 3.4.3</code></pre>
</section>
<section id="creating-tibbles" class="slide level2">
<h2>Creating tibbles</h2>
<p>Almost all of the functions in tidyverse produce tibbles, as tibbles are one of the unifying features of the tidyverse. Most other R packages use regular data frames, so you might want to coerce a data frame to a tibble. You can do that with <code>as_tibble()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as_tibble</span>(iris)</code></pre></div>
<pre><code>## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
##  1         5.10        3.50         1.40       0.200 setosa 
##  2         4.90        3.00         1.40       0.200 setosa 
##  3         4.70        3.20         1.30       0.200 setosa 
##  4         4.60        3.10         1.50       0.200 setosa 
##  5         5.00        3.60         1.40       0.200 setosa 
##  6         5.40        3.90         1.70       0.400 setosa 
##  7         4.60        3.40         1.40       0.300 setosa 
##  8         5.00        3.40         1.50       0.200 setosa 
##  9         4.40        2.90         1.40       0.200 setosa 
## 10         4.90        3.10         1.50       0.100 setosa 
## # ... with 140 more rows</code></pre>
</section>
<section id="creating-tibbles-1" class="slide level2">
<h2>Creating tibbles</h2>
<p>You can create a new tibble from individual vectors with <code>tibble()</code>. <code>tibble()</code> will automatically recycle inputs of length 1, and allows you to refer to variables that you just created, as shown below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, 
  <span class="dt">y =</span> <span class="dv">1</span>, 
  <span class="dt">z =</span> x <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>y
)</code></pre></div>
<pre><code>## # A tibble: 5 x 3
##       x     y     z
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1    1.    2.
## 2     2    1.    5.
## 3     3    1.   10.
## 4     4    1.   17.
## 5     5    1.   26.</code></pre>
</section>
<section id="differences-from-data.frame" class="slide level2">
<h2>Differences from <code>data.frame()</code></h2>
<p>If you’re already familiar with <code>data.frame()</code>, note that <code>tibble()</code> does much less: it never changes the type of the inputs (e.g. it never converts strings to factors!), it never changes the names of variables, and it never creates row names.</p>
</section>
<section id="tibble-column-names" class="slide level2">
<h2>tibble column names</h2>
<p>It’s possible for a tibble to have column names that are not valid R variable names, aka <strong>non-syntactic</strong> names. For example, they might not start with a letter, or they might contain unusual characters like a space. To refer to these variables, you need to surround them with backticks, <code>`</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tb &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="st">`</span><span class="dt">:)</span><span class="st">`</span> =<span class="st"> &quot;smile&quot;</span>, 
  <span class="st">`</span><span class="dt"> </span><span class="st">`</span> =<span class="st"> &quot;space&quot;</span>,
  <span class="st">`</span><span class="dt">2000</span><span class="st">`</span> =<span class="st"> &quot;number&quot;</span>
)
tb</code></pre></div>
<pre><code>## # A tibble: 1 x 3
##   `:)`  ` `   `2000`
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 
## 1 smile space number</code></pre>
<p>You’ll also need the backticks when working with these variables in other packages, like ggplot2, dplyr, and tidyr.</p>
</section>
<section id="tibbles-vs.data.frame" class="slide level2">
<h2>Tibbles vs. data.frame</h2>
<p>There are two main differences in the usage of a tibble vs. a classic <code>data.frame</code>: printing and subsetting.</p>
</section>
<section id="printing" class="slide level2">
<h2>Printing</h2>
<p>Tibbles have a refined print method that shows only the first 10 rows, and all the columns that fit on screen. This makes it much easier to work with large data. In addition to its name, each column reports its type, a nice feature borrowed from <code>str()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(
  <span class="dt">a =</span> lubridate<span class="op">::</span><span class="kw">now</span>() <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e3</span>) <span class="op">*</span><span class="st"> </span><span class="dv">86400</span>,
  <span class="dt">b =</span> lubridate<span class="op">::</span><span class="kw">today</span>() <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e3</span>) <span class="op">*</span><span class="st"> </span><span class="dv">30</span>,
  <span class="dt">c =</span> <span class="dv">1</span><span class="op">:</span><span class="fl">1e3</span>,
  <span class="dt">d =</span> <span class="kw">runif</span>(<span class="fl">1e3</span>),
  <span class="dt">e =</span> <span class="kw">sample</span>(letters, <span class="fl">1e3</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
)</code></pre></div>
<pre><code>## # A tibble: 1,000 x 5
##    a                   b              c      d e    
##    &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt;  &lt;dbl&gt; &lt;chr&gt;
##  1 2018-07-16 10:42:26 2018-07-28     1 0.842  u    
##  2 2018-07-16 10:01:57 2018-08-07     2 0.447  i    
##  3 2018-07-17 00:04:13 2018-07-16     3 0.375  h    
##  4 2018-07-16 22:21:20 2018-08-13     4 0.902  w    
##  5 2018-07-16 23:04:16 2018-07-21     5 0.887  y    
##  6 2018-07-16 19:36:04 2018-08-01     6 0.952  s    
##  7 2018-07-16 21:25:24 2018-08-05     7 0.869  i    
##  8 2018-07-17 02:51:52 2018-07-21     8 0.857  b    
##  9 2018-07-16 08:05:39 2018-07-25     9 0.482  p    
## 10 2018-07-16 10:35:34 2018-07-21    10 0.0322 g    
## # ... with 990 more rows</code></pre>
<p>Tibbles are designed so that you don’t accidentally overwhelm your console when you print large data frames. But sometimes you need more output than the default display. There are a few options that can help.</p>
<p>First, you can explicitly <code>print()</code> the data frame and control the number of rows (<code>n</code>) and the <code>width</code> of the display. <code>width = Inf</code> will display all columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nycflights13<span class="op">::</span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="dv">10</span>, <span class="dt">width =</span> <span class="ot">Inf</span>)</code></pre></div>
</section>
<section id="data-import-with-readr" class="slide level2">
<h2>Data import with readr</h2>
<p>If you’re used to base R, you’ve probably used functions from the <code>foreign</code> package to read in <code>.dta</code> Stata files, <code>.csv</code> files, and other data formats. <code>foreign</code> isn’t really that bad, but <code>readr</code> plays nicely with the tidyverse, is a little more flexible, and can be a lot faster.</p>
</section>
<section id="getting-started" class="slide level2">
<h2>Getting started</h2>
<p>Most of readr’s functions are concerned with turning flat files into data frames:</p>
<ul>
<li><p><code>read_csv()</code> reads comma delimited files, <code>read_csv2()</code> reads semicolon separated files (common in countries where <code>,</code> is used as the decimal place), <code>read_tsv()</code> reads tab delimited files, and <code>read_delim()</code> reads in files with any delimiter.</p></li>
<li><p><code>read_fwf()</code> reads fixed width files. You can specify fields either by their widths with <code>fwf_widths()</code> or their position with <code>fwf_positions()</code>. <code>read_table()</code> reads a common variation of fixed width files where columns are separated by white space.</p></li>
</ul>
</section>
<section id="arguments" class="slide level2">
<h2>Arguments</h2>
<p>The first argument to <code>read_csv()</code> is the most important: it’s the path to the file to read.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">heights &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/heights.csv&quot;</span>)</code></pre></div>
<p>When you run <code>read_csv()</code> it prints out a column specification that gives the name and type of each column.</p>
</section>
<section id="first-line-defaults-to-colnames-but-you-can-change-that" class="slide level2">
<h2>First line defaults to colnames, but you can change that</h2>
<ol type="1">
<li><p>Sometimes there are a few lines of metadata at the top of the file. You can use <code>skip = n</code> to skip the first <code>n</code> lines; or use <code>comment = &quot;#&quot;</code> to drop all lines that start with (e.g.) <code>#</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;The first line of metadata</span>
<span class="st">  The second line of metadata</span>
<span class="st">  x,y,z</span>
<span class="st">  1,2,3&quot;</span>, <span class="dt">skip =</span> <span class="dv">2</span>)</code></pre></div>
<pre><code>## # A tibble: 1 x 3
##       x     y     z
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     2     3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;# A comment I want to skip</span>
<span class="st">  x,y,z</span>
<span class="st">  1,2,3&quot;</span>, <span class="dt">comment =</span> <span class="st">&quot;#&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 1 x 3
##       x     y     z
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     2     3</code></pre></li>
</ol>
</section>
<section id="first-line-defaults-to-colnames-but-you-can-change-that-1" class="slide level2">
<h2>First line defaults to colnames, but you can change that</h2>
<ol type="1">
<li><p>The data might not have column names. You can use <code>col_names = FALSE</code> to tell <code>read_csv()</code> not to treat the first row as headings, and instead label them sequentially from <code>X1</code> to <code>Xn</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;1,2,3</span><span class="ch">\n</span><span class="st">4,5,6&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##      X1    X2    X3
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     2     3
## 2     4     5     6</code></pre></li>
</ol>
</section>
<section id="first-line-defaults-to-colnames-but-you-can-change-that-2" class="slide level2">
<h2>First line defaults to colnames, but you can change that</h2>
<pre><code>Alternatively you can pass `col_names` a character vector which will be
used as the column names:


```r
read_csv(&quot;1,2,3\n4,5,6&quot;, col_names = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;))
```

```
## # A tibble: 2 x 3
##       x     y     z
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     2     3
## 2     4     5     6
```</code></pre>
</section>
<section id="you-might-need-to-fix-nas." class="slide level2">
<h2>You might need to fix NAs.</h2>
<p>Another option that commonly needs tweaking is <code>na</code>: this specifies the value (or values) that are used to represent missing values in your file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a,b,c</span><span class="ch">\n</span><span class="st">1,2,.&quot;</span>, <span class="dt">na =</span> <span class="st">&quot;.&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 1 x 3
##       a     b c    
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;
## 1     1     2 &lt;NA&gt;</code></pre>
<p>This is all you need to know to read ~75% of CSV files that you’ll encounter in practice. You can also easily adapt what you’ve learned to read tab separated files with <code>read_tsv()</code> and fixed width files with <code>read_fwf()</code>. To read in more challenging files, you’ll need to learn more about how readr parses each column, turning them into R vectors.</p>
</section>
<section id="parsing" class="slide level2">
<h2>Parsing</h2>
<p>readr has lots of specialized tools for parsing different kinds of data at import. If you’re already working with nicely cleaned data, you won’t need to learn all of these. If you often work with data in non-standard formats, from Arabic-speaking countries, or from the distant past, check out <a href="http://r4ds.had.co.nz/data-import.html#parsing-a-vector">the relevant sections of R4DS</a>.</p>
</section>
<section id="parsing-decimals-across-cultures" class="slide level2">
<h2>Parsing decimals across cultures</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_double</span>(<span class="st">&quot;1.23&quot;</span>)</code></pre></div>
<pre><code>## [1] 1.23</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_double</span>(<span class="st">&quot;1,23&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">decimal_mark =</span> <span class="st">&quot;,&quot;</span>))</code></pre></div>
<pre><code>## [1] 1.23</code></pre>
</section>
<section id="clean-junk-out-of-your-numbers" class="slide level2">
<h2>Clean junk out of your numbers</h2>
<p><code>parse_number()</code> addresses the second problem: it ignores non-numeric characters before and after the number. This is particularly useful for currencies and percentages, but also works to extract numbers embedded in text.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_number</span>(<span class="st">&quot;$100&quot;</span>)</code></pre></div>
<pre><code>## [1] 100</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_number</span>(<span class="st">&quot;20%&quot;</span>)</code></pre></div>
<pre><code>## [1] 20</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_number</span>(<span class="st">&quot;It cost $123.45&quot;</span>)</code></pre></div>
<pre><code>## [1] 123.45</code></pre>
</section>
<section id="god-currency-data-is-awful" class="slide level2">
<h2>God, currency data is awful</h2>
<p>The final problem is addressed by the combination of <code>parse_number()</code> and the locale as <code>parse_number()</code> will ignore the “grouping mark”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Used in America</span>
<span class="kw">parse_number</span>(<span class="st">&quot;$123,456,789&quot;</span>)</code></pre></div>
<pre><code>## [1] 123456789</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Used in many parts of Europe</span>
<span class="kw">parse_number</span>(<span class="st">&quot;123.456.789&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">grouping_mark =</span> <span class="st">&quot;.&quot;</span>))</code></pre></div>
<pre><code>## [1] 123456789</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Used in Switzerland</span>
<span class="kw">parse_number</span>(<span class="st">&quot;123&#39;456&#39;789&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">grouping_mark =</span> <span class="st">&quot;&#39;&quot;</span>))</code></pre></div>
<pre><code>## [1] 123456789</code></pre>
</section>
<section id="study-up-on-your-own-on-character-encoding" class="slide level2">
<h2>Study up on your own on character encoding</h2>
</section>
<section id="factors" class="slide level2">
<h2>Factors</h2>
<p>R uses factors to represent categorical variables that have a known set of possible values. Give <code>parse_factor()</code> a vector of known <code>levels</code> to generate a warning whenever an unexpected value is present:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fruit &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;banana&quot;</span>)
<span class="kw">parse_factor</span>(<span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;banana&quot;</span>, <span class="st">&quot;bananana&quot;</span>), <span class="dt">levels =</span> fruit)</code></pre></div>
<pre><code>## Warning: 1 parsing failure.
## row # A tibble: 1 x 4 col     row   col expected           actual   expected   &lt;int&gt; &lt;int&gt; &lt;chr&gt;              &lt;chr&gt;    actual 1     3    NA value in level set bananana</code></pre>
<pre><code>## [1] apple  banana &lt;NA&gt;  
## attr(,&quot;problems&quot;)
## # A tibble: 1 x 4
##     row   col expected           actual  
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;              &lt;chr&gt;   
## 1     3    NA value in level set bananana
## Levels: apple banana</code></pre>
</section>
<section id="dates-date-times-and-times" class="slide level2">
<h2>Dates, date-times, and times</h2>
<p>You pick between three parsers depending on whether you want a date (the number of days since 1970-01-01), a date-time (the number of seconds since midnight 1970-01-01), or a time (the number of seconds since midnight). When called without any additional arguments:</p>
<ul>
<li><p><code>parse_datetime()</code> expects an ISO8601 date-time. ISO8601 is an international standard in which the components of a date are organised from biggest to smallest: year, month, day, hour, minute, second.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_datetime</span>(<span class="st">&quot;2010-10-01T2010&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;2010-10-01 20:10:00 UTC&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># If time is omitted, it will be set to midnight</span>
<span class="kw">parse_datetime</span>(<span class="st">&quot;20101010&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;2010-10-10 UTC&quot;</code></pre></li>
</ul>
</section>
<section id="dates-date-times-and-times-1" class="slide level2">
<h2>Dates, date-times, and times</h2>
<ul>
<li><p><code>parse_date()</code> expects a four digit year, a <code>-</code> or <code>/</code>, the month, a <code>-</code> or <code>/</code>, then the day:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_date</span>(<span class="st">&quot;2010-10-01&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;2010-10-01&quot;</code></pre></li>
</ul>
</section>
<section id="dates-date-times-and-times-2" class="slide level2">
<h2>Dates, date-times, and times</h2>
<ul>
<li><p><code>parse_time()</code> expects the hour, <code>:</code>, minutes, optionally <code>:</code> and seconds, and an optional am/pm specifier:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(hms)</code></pre></div>
<pre><code>## Warning: package &#39;hms&#39; was built under R version 3.4.3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_time</span>(<span class="st">&quot;01:10 am&quot;</span>)</code></pre></div>
<pre><code>## 01:10:00</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_time</span>(<span class="st">&quot;20:10:01&quot;</span>)</code></pre></div>
<pre><code>## 20:10:01</code></pre></li>
</ul>
</section>
<section id="dates-date-times-and-times-3" class="slide level2">
<h2>Dates, date-times, and times</h2>
<pre><code>Base R doesn&#39;t have a great built in class for time data, so we use 
the one provided in the hms package.</code></pre>
</section>
<section id="other-types-of-data" class="slide level2">
<h2>Other types of data</h2>
<ul>
<li><p><strong>haven</strong> reads SPSS, Stata, and SAS files.</p></li>
<li><p><strong>readxl</strong> reads excel files (both <code>.xls</code> and <code>.xlsx</code>).</p></li>
<li><p><strong>DBI</strong>, along with a database specific backend (e.g. <strong>RMySQL</strong>, <strong>RSQLite</strong>, <strong>RPostgreSQL</strong> etc) allows you to run SQL queries against a database and return a data frame.</p></li>
</ul>
<p>For hierarchical data: use <strong>jsonlite</strong> (by Jeroen Ooms) for json, and <strong>xml2</strong> for XML. Jenny Bryan has some excellent worked examples at <a href="https://jennybc.github.io/purrr-tutorial/" class="uri">https://jennybc.github.io/purrr-tutorial/</a>.</p>
<p>For other file types, try the <a href="https://cran.r-project.org/doc/manuals/r-release/R-data.html">R data import/export manual</a> and the <a href="https://github.com/leeper/rio"><strong>rio</strong></a> package.</p>
</section>
<section id="tidy-data" class="slide level2">
<h2>Tidy data</h2>
</section>
<section id="hadley-has-jokes" class="slide level2">
<h2>Hadley has jokes</h2>
<blockquote>
<p>“Happy families are all alike; every unhappy family is unhappy in its own way.” –– Leo Tolstoy</p>
</blockquote>
<blockquote>
<p>“Tidy datasets are all alike, but every messy dataset is messy in its own way.” –– Hadley Wickham</p>
</blockquote>
</section>
<section id="tidy-data-1" class="slide level2">
<h2>Tidy data</h2>
<p>You can represent the same underlying data in multiple ways. The example below shows the same data organised in four different ways. Each dataset shows the same values of four variables <em>country</em>, <em>year</em>, <em>population</em>, and <em>cases</em>, but each dataset organises the values in a different way.</p>
</section>
<section id="table-1" class="slide level2">
<h2>Table 1</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table1</code></pre></div>
<pre><code>## # A tibble: 6 x 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
</section>
<section id="table-2" class="slide level2">
<h2>Table 2</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table2</code></pre></div>
<pre><code>## # A tibble: 12 x 4
##    country      year type            count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583</code></pre>
</section>
<section id="table-3" class="slide level2">
<h2>Table 3</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table3</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   country      year rate             
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583</code></pre>
</section>
<section id="table-4" class="slide level2">
<h2>Table 4</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Spread across two tibbles</span>
table4a  <span class="co"># cases</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   country     `1999` `2000`
## * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table4b  <span class="co"># population</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   country         `1999`     `2000`
## * &lt;chr&gt;            &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan   19987071   20595360
## 2 Brazil       172006362  174504898
## 3 China       1272915272 1280428583</code></pre>
</section>
<section id="tidy-data-principles" class="slide level2">
<h2>Tidy data principles</h2>
<p>There are three interrelated rules which make a dataset tidy:</p>
<ol type="1">
<li>Each variable must have its own column.</li>
<li>Each observation must have its own row.</li>
<li>Each value must have its own cell.</li>
</ol>
</section>
<section id="tidy-data-principles-1" class="slide level2">
<h2>Tidy data principles</h2>
<p><img src="../images/tidy-1.png" /></p>
</section>
<section id="tidy-data-principles-2" class="slide level2">
<h2>Tidy data principles</h2>
<p>These three rules are interrelated because it’s impossible to only satisfy two of the three. That interrelationship leads to an even simpler set of practical instructions:</p>
<ol type="1">
<li>Put each dataset in a tibble.</li>
<li>Put each variable in a column.</li>
</ol>
</section>
<section id="tidy-data-principles-3" class="slide level2">
<h2>Tidy data principles</h2>
<ul>
<li>Every data task will be different, but tidy data principles will help you keep organized</li>
<li>Much of your workflow will be getting data inputs into a tidy format</li>
<li>From the beginning, lay out what you need your dataset to look like to do the analyses you want, then work backward from there</li>
<li><a href="https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html">Hadley’s vignette on tidy data principles</a></li>
<li><a href="http://r4ds.had.co.nz/tidy-data.html">Chapter of R for Data Science on tidy data</a></li>
</ul>
</section>
<section id="tidy-data-has" class="slide level2">
<h2>Tidy data has</h2>
<ul>
<li>Each variable forms a column.</li>
<li>Each observation forms a row.</li>
<li>Each type of observational unit forms a table.</li>
</ul>
</section>
<section id="tidy-data-does-not-have" class="slide level2">
<h2>Tidy data does not have</h2>
<ul>
<li>Column headers are values, not variable names.</li>
<li>Multiple variables are stored in one column.</li>
<li>Variables are stored in both rows and columns.</li>
<li>Multiple types of observational units are stored in the same table.</li>
<li>A single observational unit is stored in multiple tables.</li>
</ul>
</section>
<section id="long-vs-wide-data" class="slide level2">
<h2>Long vs wide data</h2>
<p><img src="http://seananderson.ca/images/dcast-illustration.png" alt="via Sean Anderson" /></p>
</section>
<section id="relational-data" class="slide level2">
<h2>Relational data</h2>
<ul>
<li>Some data has structures more complex than simple tables</li>
<li>For example, Netflix has a database where each user has a table of movies they’ve watched and a separate table for each movie of the users who have watched it</li>
<li>This is “relational data”</li>
<li>It’s often, but not always, big</li>
<li>Requires special tools, usually SQL</li>
</ul>
</section>
<section id="checking-up-on-your-data-cleaning" class="slide level2">
<h2>Checking up on your data cleaning</h2>
<ul>
<li>glance at your data:
<ul>
<li><code>View()</code> (but be careful!)</li>
<li><code>summary()</code> (be careful on big datasets)</li>
<li><code>head()</code> and <code>tail()</code></li>
<li><code>tibble::glimpse()</code></li>
<li><code>is.na()</code> and <code>sum(is.na())</code></li>
</ul></li>
</ul>
</section>
<section id="spreading-and-gathering" class="slide level2">
<h2>Spreading and gathering</h2>
<p>The principles of tidy data seem so obvious that you might wonder if you’ll ever encounter a dataset that isn’t tidy. Unfortunately, however, most data that you will encounter will be untidy. There are two main reasons:</p>
<ol type="1">
<li><p>Most people aren’t familiar with the principles of tidy data, and it’s hard to derive them yourself unless you spend a <em>lot</em> of time working with data.</p></li>
<li><p>Data is often organised to facilitate some use other than analysis. For example, data is often organised to make entry as easy as possible.</p></li>
</ol>
</section>
<section id="common-problems" class="slide level2">
<h2>Common problems</h2>
<ol type="1">
<li><p>One variable might be spread across multiple columns.</p></li>
<li><p>One observation might be scattered across multiple rows.</p></li>
</ol>
<p>Typically a dataset will only suffer from one of these problems; it’ll only suffer from both if you’re really unlucky! To fix these problems, you’ll need the two most important functions in tidyr: <code>gather()</code> and <code>spread()</code>.</p>
</section>
<section id="gathering" class="slide level2">
<h2>Gathering</h2>
<p>A common problem is a dataset where some of the column names are not names of variables, but <em>values</em> of a variable. Take <code>table4a</code>: the column names <code>1999</code> and <code>2000</code> represent values of the <code>year</code> variable, and each row represents two observations, not one.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table4a</code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   country     `1999` `2000`
## * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766</code></pre>
</section>
<section id="gathering-1" class="slide level2">
<h2>Gathering</h2>
<p>To tidy a dataset like this, we need to <strong>gather</strong> those columns into a new pair of variables. To describe that operation we need three parameters:</p>
<ul>
<li><p>The set of columns that represent values, not variables. In this example, those are the columns <code>1999</code> and <code>2000</code>.</p></li>
<li><p>The name of the variable whose values form the column names. I call that the <code>key</code>, and here it is <code>year</code>.</p></li>
<li><p>The name of the variable whose values are spread over the cells. I call that <code>value</code>, and here it’s the number of <code>cases</code>.</p></li>
</ul>
</section>
<section id="gathering-2" class="slide level2">
<h2>Gathering</h2>
<p>Together those parameters generate the call to <code>gather()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table4a <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cases&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   country     year   cases
##   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;
## 1 Afghanistan 1999     745
## 2 Brazil      1999   37737
## 3 China       1999  212258
## 4 Afghanistan 2000    2666
## 5 Brazil      2000   80488
## 6 China       2000  213766</code></pre>
<p>The columns to gather are specified with <code>dplyr::select()</code> style notation. Here there are only two columns, so we list them individually. Note that “1999” and “2000” are non-syntactic names (because they don’t start with a letter) so we have to surround them in backticks. To refresh your memory of the other ways to select columns, see <a href="#/select">select</a>.</p>
<div class="figure">
<img src="images/tidy-9.png" alt="Gathering `table4` into a tidy form." width="100%" />
<p class="caption">
Gathering <code>table4</code> into a tidy form.
</p>
</div>
</section>
<section id="gathering-3" class="slide level2">
<h2>Gathering</h2>
<p>In the final result, the gathered columns are dropped, and we get new <code>key</code> and <code>value</code> columns. Otherwise, the relationships between the original variables are preserved. Visually, this is shown in Figure @ref(fig:tidy-gather). We can use <code>gather()</code> to tidy <code>table4b</code> in a similar fashion. The only difference is the variable stored in the cell values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table4b <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;population&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   country     year  population
##   &lt;chr&gt;       &lt;chr&gt;      &lt;int&gt;
## 1 Afghanistan 1999    19987071
## 2 Brazil      1999   172006362
## 3 China       1999  1272915272
## 4 Afghanistan 2000    20595360
## 5 Brazil      2000   174504898
## 6 China       2000  1280428583</code></pre>
<p>To combine the tidied versions of <code>table4a</code> and <code>table4b</code> into a single tibble, we need to use <code>dplyr::left_join()</code>, which you’ll learn about in <a href="#/relational-data">relational data</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tidy4a &lt;-<span class="st"> </span>table4a <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cases&quot;</span>)
tidy4b &lt;-<span class="st"> </span>table4b <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;population&quot;</span>)
<span class="kw">left_join</span>(tidy4a, tidy4b)</code></pre></div>
<pre><code>## Joining, by = c(&quot;country&quot;, &quot;year&quot;)</code></pre>
<pre><code>## # A tibble: 6 x 4
##   country     year   cases population
##   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan 1999     745   19987071
## 2 Brazil      1999   37737  172006362
## 3 China       1999  212258 1272915272
## 4 Afghanistan 2000    2666   20595360
## 5 Brazil      2000   80488  174504898
## 6 China       2000  213766 1280428583</code></pre>
</section>
<section id="spreading" class="slide level2">
<h2>Spreading</h2>
<p>Spreading is the opposite of gathering. You use it when an observation is scattered across multiple rows. For example, take <code>table2</code>: an observation is a country in a year, but each observation is spread across two rows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table2</code></pre></div>
<pre><code>## # A tibble: 12 x 4
##    country      year type            count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583</code></pre>
<p>To tidy this up, we first analyse the representation in similar way to <code>gather()</code>. This time, however, we only need two parameters:</p>
<ul>
<li><p>The column that contains variable names, the <code>key</code> column. Here, it’s <code>type</code>.</p></li>
<li><p>The column that contains values forms multiple variables, the <code>value</code> column. Here it’s <code>count</code>.</p></li>
</ul>
<p>Once we’ve figured that out, we can use <code>spread()</code>, as shown programmatically below, and visually in Figure @ref(fig:tidy-spread).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">spread</span>(table2, <span class="dt">key =</span> type, <span class="dt">value =</span> count)</code></pre></div>
<pre><code>## # A tibble: 6 x 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<div class="figure">
<img src="images/tidy-8.png" alt="Spreading `table2` makes it tidy" width="100%" />
<p class="caption">
Spreading <code>table2</code> makes it tidy
</p>
</div>
<p>As you might have guessed from the common <code>key</code> and <code>value</code> arguments, <code>spread()</code> and <code>gather()</code> are complements. <code>gather()</code> makes wide tables narrower and longer; <code>spread()</code> makes long tables shorter and wider.</p>
<h3 id="exercises">Exercises</h3>
<ol type="1">
<li><p>Why are <code>gather()</code> and <code>spread()</code> not perfectly symmetrical?<br />
Carefully consider the following example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stocks &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">year   =</span> <span class="kw">c</span>(<span class="dv">2015</span>, <span class="dv">2015</span>, <span class="dv">2016</span>, <span class="dv">2016</span>),
  <span class="dt">half  =</span> <span class="kw">c</span>(   <span class="dv">1</span>,    <span class="dv">2</span>,     <span class="dv">1</span>,    <span class="dv">2</span>),
  <span class="dt">return =</span> <span class="kw">c</span>(<span class="fl">1.88</span>, <span class="fl">0.59</span>, <span class="fl">0.92</span>, <span class="fl">0.17</span>)
)
stocks <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">spread</span>(year, return) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">&quot;year&quot;</span>, <span class="st">&quot;return&quot;</span>, <span class="st">`</span><span class="dt">2015</span><span class="st">`</span><span class="op">:</span><span class="st">`</span><span class="dt">2016</span><span class="st">`</span>)</code></pre></div>
<p>(Hint: look at the variable types and think about column <em>names</em>.)</p>
<p>Both <code>spread()</code> and <code>gather()</code> have a <code>convert</code> argument. What does it do?</p></li>
<li><p>Why does this code fail?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table4a <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="dv">1999</span>, <span class="dv">2000</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cases&quot;</span>)</code></pre></div>
<pre><code>## Error in inds_combine(.vars, ind_list): Position must be between 0 and n</code></pre></li>
<li><p>Why does spreading this tibble fail? How could you add a new column to fix the problem?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">people &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>name,             <span class="op">~</span>key,    <span class="op">~</span>value,
  <span class="co">#-----------------|--------|------</span>
  <span class="st">&quot;Phillip Woods&quot;</span>,   <span class="st">&quot;age&quot;</span>,       <span class="dv">45</span>,
  <span class="st">&quot;Phillip Woods&quot;</span>,   <span class="st">&quot;height&quot;</span>,   <span class="dv">186</span>,
  <span class="st">&quot;Phillip Woods&quot;</span>,   <span class="st">&quot;age&quot;</span>,       <span class="dv">50</span>,
  <span class="st">&quot;Jessica Cordero&quot;</span>, <span class="st">&quot;age&quot;</span>,       <span class="dv">37</span>,
  <span class="st">&quot;Jessica Cordero&quot;</span>, <span class="st">&quot;height&quot;</span>,   <span class="dv">156</span>
)</code></pre></div></li>
<li><p>Tidy the simple tibble below. Do you need to spread or gather it? What are the variables?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">preg &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>pregnant, <span class="op">~</span>male, <span class="op">~</span>female,
  <span class="st">&quot;yes&quot;</span>,     <span class="ot">NA</span>,    <span class="dv">10</span>,
  <span class="st">&quot;no&quot;</span>,      <span class="dv">20</span>,    <span class="dv">12</span>
)</code></pre></div></li>
</ol>
</section>
<section id="separating-and-uniting" class="slide level2">
<h2>Separating and uniting</h2>
<p>So far you’ve learned how to tidy <code>table2</code> and <code>table4</code>, but not <code>table3</code>. <code>table3</code> has a different problem: we have one column (<code>rate</code>) that contains two variables (<code>cases</code> and <code>population</code>). To fix this problem, we’ll need the <code>separate()</code> function. You’ll also learn about the complement of <code>separate()</code>: <code>unite()</code>, which you use if a single variable is spread across multiple columns.</p>
<h3 id="separate">Separate</h3>
<p><code>separate()</code> pulls apart one column into multiple columns, by splitting wherever a separator character appears. Take <code>table3</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table3</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   country      year rate             
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583</code></pre>
<p>The <code>rate</code> column contains both <code>cases</code> and <code>population</code> variables, and we need to split it into two variables. <code>separate()</code> takes the name of the column to separate, and the names of the columns to separate into, as shown in Figure @ref(fig:tidy-separate) and the code below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(rate, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;cases&quot;</span>, <span class="st">&quot;population&quot;</span>))</code></pre></div>
<pre><code>## # A tibble: 6 x 4
##   country      year cases  population
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
## 1 Afghanistan  1999 745    19987071  
## 2 Afghanistan  2000 2666   20595360  
## 3 Brazil       1999 37737  172006362 
## 4 Brazil       2000 80488  174504898 
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<div class="figure">
<img src="images/tidy-17.png" alt="Separating `table3` makes it tidy" width="75%" />
<p class="caption">
Separating <code>table3</code> makes it tidy
</p>
</div>
<p>By default, <code>separate()</code> will split values wherever it sees a non-alphanumeric character (i.e. a character that isn’t a number or letter). For example, in the code above, <code>separate()</code> split the values of <code>rate</code> at the forward slash characters. If you wish to use a specific character to separate a column, you can pass the character to the <code>sep</code> argument of <code>separate()</code>. For example, we could rewrite the code above as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(rate, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;cases&quot;</span>, <span class="st">&quot;population&quot;</span>), <span class="dt">sep =</span> <span class="st">&quot;/&quot;</span>)</code></pre></div>
<p>(Formally, <code>sep</code> is a regular expression, which you’ll learn more about in [strings].)</p>
<p>Look carefully at the column types: you’ll notice that <code>case</code> and <code>population</code> are character columns. This is the default behaviour in <code>separate()</code>: it leaves the type of the column as is. Here, however, it’s not very useful as those really are numbers. We can ask <code>separate()</code> to try and convert to better types using <code>convert = TRUE</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(rate, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;cases&quot;</span>, <span class="st">&quot;population&quot;</span>), <span class="dt">convert =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## # A tibble: 6 x 4
##   country      year  cases population
## * &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<p>You can also pass a vector of integers to <code>sep</code>. <code>separate()</code> will interpret the integers as positions to split at. Positive values start at 1 on the far-left of the strings; negative value start at -1 on the far-right of the strings. When using integers to separate strings, the length of <code>sep</code> should be one less than the number of names in <code>into</code>.</p>
<p>You can use this arrangement to separate the last two digits of each year. This make this data less tidy, but is useful in other cases, as you’ll see in a little bit.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(year, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;century&quot;</span>, <span class="st">&quot;year&quot;</span>), <span class="dt">sep =</span> <span class="dv">2</span>)</code></pre></div>
<pre><code>## # A tibble: 6 x 4
##   country     century year  rate             
## * &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;            
## 1 Afghanistan 19      99    745/19987071     
## 2 Afghanistan 20      00    2666/20595360    
## 3 Brazil      19      99    37737/172006362  
## 4 Brazil      20      00    80488/174504898  
## 5 China       19      99    212258/1272915272
## 6 China       20      00    213766/1280428583</code></pre>
<h3 id="unite">Unite</h3>
<p><code>unite()</code> is the inverse of <code>separate()</code>: it combines multiple columns into a single column. You’ll need it much less frequently than <code>separate()</code>, but it’s still a useful tool to have in your back pocket.</p>
<div class="figure">
<img src="images/tidy-18.png" alt="Uniting `table5` makes it tidy" width="75%" />
<p class="caption">
Uniting <code>table5</code> makes it tidy
</p>
</div>
<p>We can use <code>unite()</code> to rejoin the <em>century</em> and <em>year</em> columns that we created in the last example. That data is saved as <code>tidyr::table5</code>. <code>unite()</code> takes a data frame, the name of the new variable to create, and a set of columns to combine, again specified in <code>dplyr::select()</code> style:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table5 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unite</span>(new, century, year)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   country     new   rate             
##   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;            
## 1 Afghanistan 19_99 745/19987071     
## 2 Afghanistan 20_00 2666/20595360    
## 3 Brazil      19_99 37737/172006362  
## 4 Brazil      20_00 80488/174504898  
## 5 China       19_99 212258/1272915272
## 6 China       20_00 213766/1280428583</code></pre>
<p>In this case we also need to use the <code>sep</code> argument. The default will place an underscore (<code>_</code>) between the values from different columns. Here we don’t want any separator so we use <code>&quot;&quot;</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table5 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unite</span>(new, century, year, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   country     new   rate             
##   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;            
## 1 Afghanistan 1999  745/19987071     
## 2 Afghanistan 2000  2666/20595360    
## 3 Brazil      1999  37737/172006362  
## 4 Brazil      2000  80488/174504898  
## 5 China       1999  212258/1272915272
## 6 China       2000  213766/1280428583</code></pre>
<h3 id="exercises-1">Exercises</h3>
<ol type="1">
<li><p>What do the <code>extra</code> and <code>fill</code> arguments do in <code>separate()</code>? Experiment with the various options for the following two toy datasets.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;a,b,c&quot;</span>, <span class="st">&quot;d,e,f,g&quot;</span>, <span class="st">&quot;h,i,j&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(x, <span class="kw">c</span>(<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>))

<span class="kw">tibble</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;a,b,c&quot;</span>, <span class="st">&quot;d,e&quot;</span>, <span class="st">&quot;f,g,i&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(x, <span class="kw">c</span>(<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>))</code></pre></div></li>
<li><p>Both <code>unite()</code> and <code>separate()</code> have a <code>remove</code> argument. What does it do? Why would you set it to <code>FALSE</code>?</p></li>
<li><p>Compare and contrast <code>separate()</code> and <code>extract()</code>. Why are there three variations of separation (by position, by separator, and with groups), but only one unite?</p></li>
</ol>
</section>
<section id="missing-values" class="slide level2">
<h2>Missing values</h2>
<p>Changing the representation of a dataset brings up an important subtlety of missing values. Surprisingly, a value can be missing in one of two possible ways:</p>
<ul>
<li><strong>Explicitly</strong>, i.e. flagged with <code>NA</code>.</li>
<li><strong>Implicitly</strong>, i.e. simply not present in the data.</li>
</ul>
<p>Let’s illustrate this idea with a very simple data set:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stocks &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">year   =</span> <span class="kw">c</span>(<span class="dv">2015</span>, <span class="dv">2015</span>, <span class="dv">2015</span>, <span class="dv">2015</span>, <span class="dv">2016</span>, <span class="dv">2016</span>, <span class="dv">2016</span>),
  <span class="dt">qtr    =</span> <span class="kw">c</span>(   <span class="dv">1</span>,    <span class="dv">2</span>,    <span class="dv">3</span>,    <span class="dv">4</span>,    <span class="dv">2</span>,    <span class="dv">3</span>,    <span class="dv">4</span>),
  <span class="dt">return =</span> <span class="kw">c</span>(<span class="fl">1.88</span>, <span class="fl">0.59</span>, <span class="fl">0.35</span>,   <span class="ot">NA</span>, <span class="fl">0.92</span>, <span class="fl">0.17</span>, <span class="fl">2.66</span>)
)</code></pre></div>
<p>There are two missing values in this dataset:</p>
<ul>
<li><p>The return for the fourth quarter of 2015 is explicitly missing, because the cell where its value should be instead contains <code>NA</code>.</p></li>
<li><p>The return for the first quarter of 2016 is implicitly missing, because it simply does not appear in the dataset.</p></li>
</ul>
<p>One way to think about the difference is with this Zen-like koan: An explicit missing value is the presence of an absence; an implicit missing value is the absence of a presence.</p>
<p>The way that a dataset is represented can make implicit values explicit. For example, we can make the implicit missing value explicit by putting years in the columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stocks <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">spread</span>(year, return)</code></pre></div>
<pre><code>## # A tibble: 4 x 3
##     qtr `2015` `2016`
##   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1    1.  1.88  NA    
## 2    2.  0.590  0.920
## 3    3.  0.350  0.170
## 4    4. NA      2.66</code></pre>
<p>Because these explicit missing values may not be important in other representations of the data, you can set <code>na.rm = TRUE</code> in <code>gather()</code> to turn explicit missing values implicit:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stocks <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">spread</span>(year, return) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(year, return, <span class="st">`</span><span class="dt">2015</span><span class="st">`</span><span class="op">:</span><span class="st">`</span><span class="dt">2016</span><span class="st">`</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##     qtr year  return
## * &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;
## 1    1. 2015   1.88 
## 2    2. 2015   0.590
## 3    3. 2015   0.350
## 4    2. 2016   0.920
## 5    3. 2016   0.170
## 6    4. 2016   2.66</code></pre>
<p>Another important tool for making missing values explicit in tidy data is <code>complete()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stocks <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">complete</span>(year, qtr)</code></pre></div>
<pre><code>## # A tibble: 8 x 3
##    year   qtr return
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1 2015.    1.  1.88 
## 2 2015.    2.  0.590
## 3 2015.    3.  0.350
## 4 2015.    4. NA    
## 5 2016.    1. NA    
## 6 2016.    2.  0.920
## 7 2016.    3.  0.170
## 8 2016.    4.  2.66</code></pre>
<p><code>complete()</code> takes a set of columns, and finds all unique combinations. It then ensures the original dataset contains all those values, filling in explicit <code>NA</code>s where necessary.</p>
<p>There’s one other important tool that you should know for working with missing values. Sometimes when a data source has primarily been used for data entry, missing values indicate that the previous value should be carried forward:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">treatment &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span><span class="st"> </span>person,           <span class="op">~</span><span class="st"> </span>treatment, <span class="op">~</span>response,
  <span class="st">&quot;Derrick Whitmore&quot;</span>, <span class="dv">1</span>,           <span class="dv">7</span>,
  <span class="ot">NA</span>,                 <span class="dv">2</span>,           <span class="dv">10</span>,
  <span class="ot">NA</span>,                 <span class="dv">3</span>,           <span class="dv">9</span>,
  <span class="st">&quot;Katherine Burke&quot;</span>,  <span class="dv">1</span>,           <span class="dv">4</span>
)</code></pre></div>
<p>You can fill in these missing values with <code>fill()</code>. It takes a set of columns where you want missing values to be replaced by the most recent non-missing value (sometimes called last observation carried forward).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">treatment <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">fill</span>(person)</code></pre></div>
<pre><code>## # A tibble: 4 x 3
##   person           treatment response
##   &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;
## 1 Derrick Whitmore        1.       7.
## 2 Derrick Whitmore        2.      10.
## 3 Derrick Whitmore        3.       9.
## 4 Katherine Burke         1.       4.</code></pre>
<h3 id="exercises-2">Exercises</h3>
<ol type="1">
<li><p>Compare and contrast the <code>fill</code> arguments to <code>spread()</code> and <code>complete()</code>.</p></li>
<li><p>What does the direction argument to <code>fill()</code> do?</p></li>
</ol>
</section>
<section id="case-study" class="slide level2">
<h2>Case Study</h2>
<p>To finish off the chapter, let’s pull together everything you’ve learned to tackle a realistic data tidying problem. The <code>tidyr::who</code> dataset contains tuberculosis (TB) cases broken down by year, country, age, gender, and diagnosis method. The data comes from the <em>2014 World Health Organization Global Tuberculosis Report</em>, available at <a href="http://www.who.int/tb/country/data/download/en/" class="uri">http://www.who.int/tb/country/data/download/en/</a>.</p>
<p>There’s a wealth of epidemiological information in this dataset, but it’s challenging to work with the data in the form that it’s provided:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">who</code></pre></div>
<pre><code>## # A tibble: 7,240 x 60
##    country     iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt;       &lt;int&gt;        &lt;int&gt;        &lt;int&gt;
##  1 Afghanistan AF    AFG    1980          NA           NA           NA
##  2 Afghanistan AF    AFG    1981          NA           NA           NA
##  3 Afghanistan AF    AFG    1982          NA           NA           NA
##  4 Afghanistan AF    AFG    1983          NA           NA           NA
##  5 Afghanistan AF    AFG    1984          NA           NA           NA
##  6 Afghanistan AF    AFG    1985          NA           NA           NA
##  7 Afghanistan AF    AFG    1986          NA           NA           NA
##  8 Afghanistan AF    AFG    1987          NA           NA           NA
##  9 Afghanistan AF    AFG    1988          NA           NA           NA
## 10 Afghanistan AF    AFG    1989          NA           NA           NA
## # ... with 7,230 more rows, and 53 more variables: new_sp_m3544 &lt;int&gt;,
## #   new_sp_m4554 &lt;int&gt;, new_sp_m5564 &lt;int&gt;, new_sp_m65 &lt;int&gt;,
## #   new_sp_f014 &lt;int&gt;, new_sp_f1524 &lt;int&gt;, new_sp_f2534 &lt;int&gt;,
## #   new_sp_f3544 &lt;int&gt;, new_sp_f4554 &lt;int&gt;, new_sp_f5564 &lt;int&gt;,
## #   new_sp_f65 &lt;int&gt;, new_sn_m014 &lt;int&gt;, new_sn_m1524 &lt;int&gt;,
## #   new_sn_m2534 &lt;int&gt;, new_sn_m3544 &lt;int&gt;, new_sn_m4554 &lt;int&gt;,
## #   new_sn_m5564 &lt;int&gt;, new_sn_m65 &lt;int&gt;, new_sn_f014 &lt;int&gt;,
## #   new_sn_f1524 &lt;int&gt;, new_sn_f2534 &lt;int&gt;, new_sn_f3544 &lt;int&gt;,
## #   new_sn_f4554 &lt;int&gt;, new_sn_f5564 &lt;int&gt;, new_sn_f65 &lt;int&gt;,
## #   new_ep_m014 &lt;int&gt;, new_ep_m1524 &lt;int&gt;, new_ep_m2534 &lt;int&gt;,
## #   new_ep_m3544 &lt;int&gt;, new_ep_m4554 &lt;int&gt;, new_ep_m5564 &lt;int&gt;,
## #   new_ep_m65 &lt;int&gt;, new_ep_f014 &lt;int&gt;, new_ep_f1524 &lt;int&gt;,
## #   new_ep_f2534 &lt;int&gt;, new_ep_f3544 &lt;int&gt;, new_ep_f4554 &lt;int&gt;,
## #   new_ep_f5564 &lt;int&gt;, new_ep_f65 &lt;int&gt;, newrel_m014 &lt;int&gt;,
## #   newrel_m1524 &lt;int&gt;, newrel_m2534 &lt;int&gt;, newrel_m3544 &lt;int&gt;,
## #   newrel_m4554 &lt;int&gt;, newrel_m5564 &lt;int&gt;, newrel_m65 &lt;int&gt;,
## #   newrel_f014 &lt;int&gt;, newrel_f1524 &lt;int&gt;, newrel_f2534 &lt;int&gt;,
## #   newrel_f3544 &lt;int&gt;, newrel_f4554 &lt;int&gt;, newrel_f5564 &lt;int&gt;,
## #   newrel_f65 &lt;int&gt;</code></pre>
<p>This is a very typical real-life example dataset. It contains redundant columns, odd variable codes, and many missing values. In short, <code>who</code> is messy, and we’ll need multiple steps to tidy it. Like dplyr, tidyr is designed so that each function does one thing well. That means in real-life situations you’ll usually need to string together multiple verbs into a pipeline.</p>
<p>The best place to start is almost always to gather together the columns that are not variables. Let’s have a look at what we’ve got:</p>
<ul>
<li><p>It looks like <code>country</code>, <code>iso2</code>, and <code>iso3</code> are three variables that redundantly specify the country.</p></li>
<li><p><code>year</code> is clearly also a variable.</p></li>
<li><p>We don’t know what all the other columns are yet, but given the structure in the variable names (e.g. <code>new_sp_m014</code>, <code>new_ep_m014</code>, <code>new_ep_f014</code>) these are likely to be values, not variables.</p></li>
</ul>
<p>So we need to gather together all the columns from <code>new_sp_m014</code> to <code>newrel_f65</code>. We don’t know what those values represent yet, so we’ll give them the generic name <code>&quot;key&quot;</code>. We know the cells represent the count of cases, so we’ll use the variable <code>cases</code>. There are a lot of missing values in the current representation, so for now we’ll use <code>na.rm</code> just so we can focus on the values that are present.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">who1 &lt;-<span class="st"> </span>who <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(new_sp_m014<span class="op">:</span>newrel_f65, <span class="dt">key =</span> <span class="st">&quot;key&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cases&quot;</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
who1</code></pre></div>
<pre><code>## # A tibble: 76,046 x 6
##    country     iso2  iso3   year key         cases
##  * &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1 Afghanistan AF    AFG    1997 new_sp_m014     0
##  2 Afghanistan AF    AFG    1998 new_sp_m014    30
##  3 Afghanistan AF    AFG    1999 new_sp_m014     8
##  4 Afghanistan AF    AFG    2000 new_sp_m014    52
##  5 Afghanistan AF    AFG    2001 new_sp_m014   129
##  6 Afghanistan AF    AFG    2002 new_sp_m014    90
##  7 Afghanistan AF    AFG    2003 new_sp_m014   127
##  8 Afghanistan AF    AFG    2004 new_sp_m014   139
##  9 Afghanistan AF    AFG    2005 new_sp_m014   151
## 10 Afghanistan AF    AFG    2006 new_sp_m014   193
## # ... with 76,036 more rows</code></pre>
<p>We can get some hint of the structure of the values in the new <code>key</code> column by counting them:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">who1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(key)</code></pre></div>
<pre><code>## # A tibble: 56 x 2
##    key              n
##    &lt;chr&gt;        &lt;int&gt;
##  1 new_ep_f014   1032
##  2 new_ep_f1524  1021
##  3 new_ep_f2534  1021
##  4 new_ep_f3544  1021
##  5 new_ep_f4554  1017
##  6 new_ep_f5564  1017
##  7 new_ep_f65    1014
##  8 new_ep_m014   1038
##  9 new_ep_m1524  1026
## 10 new_ep_m2534  1020
## # ... with 46 more rows</code></pre>
<p>You might be able to parse this out by yourself with a little thought and some experimentation, but luckily we have the data dictionary handy. It tells us:</p>
<ol type="1">
<li><p>The first three letters of each column denote whether the column contains new or old cases of TB. In this dataset, each column contains new cases.</p></li>
<li><p>The next two letters describe the type of TB:</p>
<ul>
<li><code>rel</code> stands for cases of relapse</li>
<li><code>ep</code> stands for cases of extrapulmonary TB</li>
<li><code>sn</code> stands for cases of pulmonary TB that could not be diagnosed by a pulmonary smear (smear negative)</li>
<li><code>sp</code> stands for cases of pulmonary TB that could be diagnosed be a pulmonary smear (smear positive)</li>
</ul></li>
<li><p>The sixth letter gives the sex of TB patients. The dataset groups cases by males (<code>m</code>) and females (<code>f</code>).</p></li>
<li><p>The remaining numbers gives the age group. The dataset groups cases into seven age groups:</p>
<ul>
<li><code>014</code> = 0 – 14 years old</li>
<li><code>1524</code> = 15 – 24 years old</li>
<li><code>2534</code> = 25 – 34 years old</li>
<li><code>3544</code> = 35 – 44 years old</li>
<li><code>4554</code> = 45 – 54 years old</li>
<li><code>5564</code> = 55 – 64 years old</li>
<li><code>65</code> = 65 or older</li>
</ul></li>
</ol>
<p>We need to make a minor fix to the format of the column names: unfortunately the names are slightly inconsistent because instead of <code>new_rel</code> we have <code>newrel</code> (it’s hard to spot this here but if you don’t fix it we’ll get errors in subsequent steps). You’ll learn about <code>str_replace()</code> in [strings], but the basic idea is pretty simple: replace the characters “newrel” with “new_rel”. This makes all variable names consistent.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">who2 &lt;-<span class="st"> </span>who1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">key =</span> stringr<span class="op">::</span><span class="kw">str_replace</span>(key, <span class="st">&quot;newrel&quot;</span>, <span class="st">&quot;new_rel&quot;</span>))</code></pre></div>
<pre><code>## Warning: package &#39;bindrcpp&#39; was built under R version 3.4.4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">who2</code></pre></div>
<pre><code>## # A tibble: 76,046 x 6
##    country     iso2  iso3   year key         cases
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1 Afghanistan AF    AFG    1997 new_sp_m014     0
##  2 Afghanistan AF    AFG    1998 new_sp_m014    30
##  3 Afghanistan AF    AFG    1999 new_sp_m014     8
##  4 Afghanistan AF    AFG    2000 new_sp_m014    52
##  5 Afghanistan AF    AFG    2001 new_sp_m014   129
##  6 Afghanistan AF    AFG    2002 new_sp_m014    90
##  7 Afghanistan AF    AFG    2003 new_sp_m014   127
##  8 Afghanistan AF    AFG    2004 new_sp_m014   139
##  9 Afghanistan AF    AFG    2005 new_sp_m014   151
## 10 Afghanistan AF    AFG    2006 new_sp_m014   193
## # ... with 76,036 more rows</code></pre>
<p>We can separate the values in each code with two passes of <code>separate()</code>. The first pass will split the codes at each underscore.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">who3 &lt;-<span class="st"> </span>who2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(key, <span class="kw">c</span>(<span class="st">&quot;new&quot;</span>, <span class="st">&quot;type&quot;</span>, <span class="st">&quot;sexage&quot;</span>), <span class="dt">sep =</span> <span class="st">&quot;_&quot;</span>)
who3</code></pre></div>
<pre><code>## # A tibble: 76,046 x 8
##    country     iso2  iso3   year new   type  sexage cases
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;int&gt;
##  1 Afghanistan AF    AFG    1997 new   sp    m014       0
##  2 Afghanistan AF    AFG    1998 new   sp    m014      30
##  3 Afghanistan AF    AFG    1999 new   sp    m014       8
##  4 Afghanistan AF    AFG    2000 new   sp    m014      52
##  5 Afghanistan AF    AFG    2001 new   sp    m014     129
##  6 Afghanistan AF    AFG    2002 new   sp    m014      90
##  7 Afghanistan AF    AFG    2003 new   sp    m014     127
##  8 Afghanistan AF    AFG    2004 new   sp    m014     139
##  9 Afghanistan AF    AFG    2005 new   sp    m014     151
## 10 Afghanistan AF    AFG    2006 new   sp    m014     193
## # ... with 76,036 more rows</code></pre>
<p>Then we might as well drop the <code>new</code> column because it’s constant in this dataset. While we’re dropping columns, let’s also drop <code>iso2</code> and <code>iso3</code> since they’re redundant.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">who3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(new)</code></pre></div>
<pre><code>## # A tibble: 1 x 2
##   new       n
##   &lt;chr&gt; &lt;int&gt;
## 1 new   76046</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">who4 &lt;-<span class="st"> </span>who3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>new, <span class="op">-</span>iso2, <span class="op">-</span>iso3)</code></pre></div>
<p>Next we’ll separate <code>sexage</code> into <code>sex</code> and <code>age</code> by splitting after the first character:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">who5 &lt;-<span class="st"> </span>who4 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(sexage, <span class="kw">c</span>(<span class="st">&quot;sex&quot;</span>, <span class="st">&quot;age&quot;</span>), <span class="dt">sep =</span> <span class="dv">1</span>)
who5</code></pre></div>
<pre><code>## # A tibble: 76,046 x 6
##    country      year type  sex   age   cases
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt;
##  1 Afghanistan  1997 sp    m     014       0
##  2 Afghanistan  1998 sp    m     014      30
##  3 Afghanistan  1999 sp    m     014       8
##  4 Afghanistan  2000 sp    m     014      52
##  5 Afghanistan  2001 sp    m     014     129
##  6 Afghanistan  2002 sp    m     014      90
##  7 Afghanistan  2003 sp    m     014     127
##  8 Afghanistan  2004 sp    m     014     139
##  9 Afghanistan  2005 sp    m     014     151
## 10 Afghanistan  2006 sp    m     014     193
## # ... with 76,036 more rows</code></pre>
<p>The <code>who</code> dataset is now tidy!</p>
<p>I’ve shown you the code a piece at a time, assigning each interim result to a new variable. This typically isn’t how you’d work interactively. Instead, you’d gradually build up a complex pipe:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">who <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">gather</span>(code, value, new_sp_m014<span class="op">:</span>newrel_f65, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">code =</span> stringr<span class="op">::</span><span class="kw">str_replace</span>(code, <span class="st">&quot;newrel&quot;</span>, <span class="st">&quot;new_rel&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">separate</span>(code, <span class="kw">c</span>(<span class="st">&quot;new&quot;</span>, <span class="st">&quot;var&quot;</span>, <span class="st">&quot;sexage&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>new, <span class="op">-</span>iso2, <span class="op">-</span>iso3) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(sexage, <span class="kw">c</span>(<span class="st">&quot;sex&quot;</span>, <span class="st">&quot;age&quot;</span>), <span class="dt">sep =</span> <span class="dv">1</span>)</code></pre></div>
<h3 id="exercises-3">Exercises</h3>
<ol type="1">
<li><p>In this case study I set <code>na.rm = TRUE</code> just to make it easier to check that we had the correct values. Is this reasonable? Think about how missing values are represented in this dataset. Are there implicit missing values? What’s the difference between an <code>NA</code> and zero?</p></li>
<li><p>What happens if you neglect the <code>mutate()</code> step? (<code>mutate(key = stringr::str_replace(key, &quot;newrel&quot;, &quot;new_rel&quot;))</code>)</p></li>
<li><p>I claimed that <code>iso2</code> and <code>iso3</code> were redundant with <code>country</code>. Confirm this claim.</p></li>
<li><p>For each country, year, and sex compute the total number of cases of TB. Make an informative visualisation of the data.</p></li>
</ol>
</section>
<section id="non-tidy-data" class="slide level2">
<h2>Non-tidy data</h2>
<p>Before we continue on to other topics, it’s worth talking briefly about non-tidy data. Earlier in the chapter, I used the pejorative term “messy” to refer to non-tidy data. That’s an oversimplification: there are lots of useful and well-founded data structures that are not tidy data. There are two main reasons to use other data structures:</p>
<ul>
<li><p>Alternative representations may have substantial performance or space advantages.</p></li>
<li><p>Specialised fields have evolved their own conventions for storing data that may be quite different to the conventions of tidy data.</p></li>
</ul>
<p>Either of these reasons means you’ll need something other than a tibble (or data frame). If your data does fit naturally into a rectangular structure composed of observations and variables, I think tidy data should be your default choice. But there are good reasons to use other structures; tidy data is not the only way.</p>
<p>If you’d like to learn more about non-tidy data, I’d highly recommend this thoughtful blog post by Jeff Leek: <a href="http://simplystatistics.org/2016/02/17/non-tidy-data/" class="uri">http://simplystatistics.org/2016/02/17/non-tidy-data/</a></p>
</section>
    </div>
  </div>

  <script src="part3_tidyr_files/reveal.js-3.3.0.1/lib/js/head.min.js"></script>
  <script src="part3_tidyr_files/reveal.js-3.3.0.1/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Vertical centering of slides
        center: false,
        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom
        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom



        // Optional reveal.js plugins
        dependencies: [
        ]
      });
    </script>
  <!-- dynamically load mathjax for compatibility with self-contained -->
  <script>
    (function () {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
      document.getElementsByTagName("head")[0].appendChild(script);
    })();
  </script>

<script>
  (function() {
    if (window.jQuery) {
      Reveal.addEventListener( 'slidechanged', function(event) {  
        window.jQuery(event.previousSlide).trigger('hidden');
        window.jQuery(event.currentSlide).trigger('shown');
      });
    }
  })();
</script>


  </body>
</html>
